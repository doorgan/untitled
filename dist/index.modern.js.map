{"version":3,"file":"index.modern.js","sources":["../node_modules/umap/esm/index.js","../node_modules/uparser/esm/index.js","../node_modules/uarray/esm/index.js","../node_modules/uwire/esm/index.js","../node_modules/@ungap/create-content/esm/index.js","../node_modules/uhtml/esm/node.js","../node_modules/uhtml/esm/handlers.js","../node_modules/udomdiff/esm/index.js","../node_modules/uhandlers/esm/index.js","../node_modules/uhtml/esm/rabbit.js","../node_modules/uhtml/esm/index.js","../node_modules/plain-tag/esm/index.js","../node_modules/ramda/src/internal/_arity.js","../node_modules/ramda/src/internal/_isPlaceholder.js","../node_modules/ramda/src/internal/_curry1.js","../node_modules/ramda/src/internal/_curryN.js","../node_modules/ramda/src/internal/_curry2.js","../node_modules/ramda/src/curryN.js","../node_modules/flyd/lib/index.js","../node_modules/mergerino/dist/mergerino.min.js","../src/state.ts","../node_modules/reactive-props/esm/object.js","../node_modules/reactive-props/esm/utils.js","../src/index.ts","../node_modules/reactive-props/esm/dom.js"],"sourcesContent":["export default _ => ({\n  // About: get: _.get.bind(_)\n  // It looks like WebKit/Safari didn't optimize bind at all,\n  // so that using bind slows it down by 60%.\n  // Firefox and Chrome are just fine in both cases,\n  // so let's use the approach that works fast everywhere 👍\n  get: key => _.get(key),\n  set: (key, value) => (_.set(key, value), value)\n});\n","const attr = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)$/;\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst node = /<[a-z][^>]+$/i;\nconst notNode = />[^<>]*$/;\nconst selfClosing = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/>)/ig;\nconst trimEnd = /\\s+$/;\n\nconst isNode = (template, i) => (\n    0 < i-- && (\n    node.test(template[i]) || (\n      !notNode.test(template[i]) && isNode(template, i)\n    )\n  )\n);\n\nconst regular = (original, name, extra) => empty.test(name) ?\n                  original : `<${name}${extra.replace(trimEnd,'')}></${name}>`;\n\nexport default (template, prefix, svg) => {\n  const text = [];\n  const {length} = template;\n  for (let i = 1; i < length; i++) {\n    const chunk = template[i - 1];\n    text.push(attr.test(chunk) && isNode(template, i) ?\n      chunk.replace(\n        attr,\n        (_, $1, $2) => `${prefix}${i - 1}=${$2 || '\"'}${$1}${$2 ? '' : '\"'}`\n      ) :\n      `${chunk}<!--${prefix}${i - 1}-->`\n    );\n  }\n  text.push(template[length - 1]);\n  const output = text.join('').trim();\n  return svg ? output : output.replace(selfClosing, regular);\n};\n","const {isArray} = Array;\nconst {indexOf, slice} = [];\n\nexport {isArray, indexOf, slice};\n","import {slice} from 'uarray';\n\nconst ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nexport const diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nexport const persistent = fragment => {\n  const {childNodes} = fragment;\n  const {length} = childNodes;\n  if (length < 2)\n    return length ? childNodes[0] : fragment;\n  const nodes = slice.call(childNodes, 0);\n  const firstChild = nodes[0];\n  const lastChild = nodes[length - 1];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== length) {\n        let i = 0;\n        while (i < length)\n          fragment.appendChild(nodes[i++]);\n      }\n      return fragment;\n    }\n  };\n};\n","/*! (c) Andrea Giammarchi - ISC */\nvar createContent = (function (document) {'use strict';\n  var FRAGMENT = 'fragment';\n  var TEMPLATE = 'template';\n  var HAS_CONTENT = 'content' in create(TEMPLATE);\n\n  var createHTML = HAS_CONTENT ?\n    function (html) {\n      var template = create(TEMPLATE);\n      template.innerHTML = html;\n      return template.content;\n    } :\n    function (html) {\n      var content = create(FRAGMENT);\n      var template = create(TEMPLATE);\n      var childNodes = null;\n      if (/^[^\\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)) {\n        var selector = RegExp.$1;\n        template.innerHTML = '<table>' + html + '</table>';\n        childNodes = template.querySelectorAll(selector);\n      } else {\n        template.innerHTML = html;\n        childNodes = template.childNodes;\n      }\n      append(content, childNodes);\n      return content;\n    };\n\n  return function createContent(markup, type) {\n    return (type === 'svg' ? createSVG : createHTML)(markup);\n  };\n\n  function append(root, childNodes) {\n    var length = childNodes.length;\n    while (length--)\n      root.appendChild(childNodes[0]);\n  }\n\n  function create(element) {\n    return element === FRAGMENT ?\n      document.createDocumentFragment() :\n      document.createElementNS('http://www.w3.org/1999/xhtml', element);\n  }\n\n  // it could use createElementNS when hasNode is there\n  // but this fallback is equally fast and easier to maintain\n  // it is also battle tested already in all IE\n  function createSVG(svg) {\n    var content = create(FRAGMENT);\n    var template = create('div');\n    template.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\">' + svg + '</svg>';\n    append(content, template.firstChild.childNodes);\n    return content;\n  }\n\n}(document));\nexport default createContent;\n","import createContent from '@ungap/create-content';\nimport {indexOf} from 'uarray';\n\n// from a generic path, retrieves the exact targeted node\nexport const reducePath = ({childNodes}, i) => childNodes[i];\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nexport const createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    parentNode = node.parentNode;\n  }\n  return path;\n};\n\nconst {createTreeWalker, importNode} = document;\nexport {createTreeWalker, importNode};\n\n// this \"hack\" tells the library if the browser is IE11 or old Edge\nconst isImportNodeLengthWrong = importNode.length != 1;\n\n// IE11 and old Edge discard empty nodes when cloning, potentially\n// resulting in broken paths to find updates. The workaround here\n// is to import once, upfront, the fragment that will be cloned\n// later on, so that paths are retrieved from one already parsed,\n// hence without missing child nodes once re-cloned.\nexport const createFragment = isImportNodeLengthWrong ?\n  (text, type) => importNode.call(\n    document,\n    createContent(text, type),\n    true\n  ) :\n  createContent;\n\n// IE11 and old Edge have a different createTreeWalker signature that\n// has been deprecated in other browsers. This export is needed only\n// to guarantee the TreeWalker doesn't show warnings and, ultimately, works\nexport const createWalker = isImportNodeLengthWrong ?\n  fragment => createTreeWalker.call(document, fragment, 1 | 128, null, false) :\n  fragment => createTreeWalker.call(document, fragment, 1 | 128);\n","import {isArray, slice} from 'uarray';\nimport udomdiff from 'udomdiff';\nimport {aria, attribute, data, event, ref, setter, text} from 'uhandlers';\nimport {diffable} from 'uwire';\n\nimport {reducePath} from './node.js';\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (text)\n            text.textContent = newValue;\n          else\n            text = document.createTextNode(newValue);\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if ('ELEMENT_NODE' in newValue && oldValue !== newValue) {\n          oldValue = newValue;\n          nodes = diff(\n            comment,\n            nodes,\n            newValue.nodeType === 11 ?\n              slice.call(newValue.childNodes) :\n              [newValue]\n          );\n        }\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  if (name === 'ref')\n    return ref(node);\n\n  if (name === 'aria')\n    return aria(node);\n\n  if (name === '.dataset')\n    return data(node);\n\n  if (name.slice(0, 1) === '.')\n    return setter(node, name.slice(1));\n\n  if (name.slice(0, 2) === 'on')\n    return event(node, name);\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nexport function handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n};\n","/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n","import {isArray} from 'uarray';\n\nexport const aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nexport const attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    if (oldValue !== newValue) {\n      oldValue = newValue;\n      if (oldValue == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        attributeNode.value = newValue;\n        if (orphan) {\n          node.setAttributeNodeNS(attributeNode);\n          orphan = false;\n        }\n      }\n    }\n  };\n};\n\nexport const data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nexport const event = (node, name) => {\n  let oldValue, type = name.slice(2);\n  if (!(name in node) && name.toLowerCase() in node)\n    type = type.toLowerCase();\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nexport const ref = node => value => {\n  if (typeof value === 'function')\n    value(node);\n  else\n    value.current = node;\n};\n\nexport const setter = (node, key) => value => {\n  node[key] = value;\n};\n\nexport const text = node => {\n  let oldValue;\n  return newValue => {\n    if (oldValue != newValue) {\n      oldValue = newValue;\n      node.textContent = newValue == null ? '' : newValue;\n    }\n  };\n};\n","import umap from 'umap';\nimport instrument from 'uparser';\nimport {isArray} from 'uarray';\nimport {persistent} from 'uwire';\n\nimport {handlers} from './handlers.js';\nimport {createFragment, createPath, createWalker, importNode} from './node.js';\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// isµX=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--isµX-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--isµX--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'isµ';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = umap(new WeakMap);\n\nexport const createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const text = instrument(template, prefix, type === 'svg');\n  const content = createFragment(text, type);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createWalker(content);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div isµ0=\"attr\" isµ1=\"other\"><!--isµ2--><style><!--isµ3--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains isµX\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.textContent === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named isµX and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"isµX\")\n      // the isµX attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search),\n          //svg: svg < 0 ? (svg = ('ownerSVGElement' in node ? 1 : 0)) : svg\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style or a textarea one, check its content\n      // and if it is <!--isµX--> then update tex-only this node\n      if (\n        /^(?:style|textarea)$/i.test(node.tagName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        node.textContent = '';\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = importNode.call(document, content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nexport const unroll = (info, {type, template, values}) => {\n  const {length} = values;\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  unrollValues(info, values, length);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values, length) => {\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(\n        stack[i] || (stack[i] = createCache()),\n        hole,\n        hole.length\n      );\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nexport function Hole(type, template, values) {\n  this.type = type;\n  this.template = template;\n  this.values = values;\n};\n","import umap from 'umap';\nimport {Hole, createCache, unroll} from './rabbit.js';\n\nconst {create, defineProperties} = Object;\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = umap(new WeakMap);\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return defineProperties(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      for: {\n        // keyed operations need a reference object, usually the parent node\n        // which is showing keyed results, and optionally a unique id per each\n        // related node, handy with JSON results and mutable list of objects\n        // that usually carry a unique identifier\n        value(ref, id) {\n          const memo = keyed.get(ref) || keyed.set(ref, create(null));\n          return memo[id] || (memo[id] = fixed(createCache()));\n        }\n      },\n      node: {\n        // it is possible to create one-off content out of the box via node tag\n        // this might return the single created node, or a fragment with all\n        // nodes present at the root level and, of course, their child nodes\n        value: (template, ...values) => unroll(\n          createCache(),\n          {type, template, values}\n        ).valueOf()\n      }\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache = umap(new WeakMap);\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache.get(where) || cache.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    where.textContent = '';\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.appendChild(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nexport {Hole, render, html, svg};\n","export default function (t) {\n  for (var s = t[0], i = 1, l = arguments.length; i < l; i++)\n    s += arguments[i] + t[i];\n  return s;\n};\n","function _arity(n, fn) {\n  /* eslint-disable no-unused-vars */\n  switch (n) {\n    case 0:\n      return function () {\n        return fn.apply(this, arguments);\n      };\n    case 1:\n      return function (a0) {\n        return fn.apply(this, arguments);\n      };\n    case 2:\n      return function (a0, a1) {\n        return fn.apply(this, arguments);\n      };\n    case 3:\n      return function (a0, a1, a2) {\n        return fn.apply(this, arguments);\n      };\n    case 4:\n      return function (a0, a1, a2, a3) {\n        return fn.apply(this, arguments);\n      };\n    case 5:\n      return function (a0, a1, a2, a3, a4) {\n        return fn.apply(this, arguments);\n      };\n    case 6:\n      return function (a0, a1, a2, a3, a4, a5) {\n        return fn.apply(this, arguments);\n      };\n    case 7:\n      return function (a0, a1, a2, a3, a4, a5, a6) {\n        return fn.apply(this, arguments);\n      };\n    case 8:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n        return fn.apply(this, arguments);\n      };\n    case 9:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n        return fn.apply(this, arguments);\n      };\n    case 10:\n      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n        return fn.apply(this, arguments);\n      };\n    default:\n      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n  }\n}\nmodule.exports = _arity;","function _isPlaceholder(a) {\n       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n}\nmodule.exports = _isPlaceholder;","var _isPlaceholder = /*#__PURE__*/require('./_isPlaceholder');\n\n/**\n * Optimized internal one-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry1(fn) {\n  return function f1(a) {\n    if (arguments.length === 0 || _isPlaceholder(a)) {\n      return f1;\n    } else {\n      return fn.apply(this, arguments);\n    }\n  };\n}\nmodule.exports = _curry1;","var _arity = /*#__PURE__*/require('./_arity');\n\nvar _isPlaceholder = /*#__PURE__*/require('./_isPlaceholder');\n\n/**\n * Internal curryN function.\n *\n * @private\n * @category Function\n * @param {Number} length The arity of the curried function.\n * @param {Array} received An array of arguments received thus far.\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curryN(length, received, fn) {\n  return function () {\n    var combined = [];\n    var argsIdx = 0;\n    var left = length;\n    var combinedIdx = 0;\n    while (combinedIdx < received.length || argsIdx < arguments.length) {\n      var result;\n      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n        result = received[combinedIdx];\n      } else {\n        result = arguments[argsIdx];\n        argsIdx += 1;\n      }\n      combined[combinedIdx] = result;\n      if (!_isPlaceholder(result)) {\n        left -= 1;\n      }\n      combinedIdx += 1;\n    }\n    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n  };\n}\nmodule.exports = _curryN;","var _curry1 = /*#__PURE__*/require('./_curry1');\n\nvar _isPlaceholder = /*#__PURE__*/require('./_isPlaceholder');\n\n/**\n * Optimized internal two-arity curry function.\n *\n * @private\n * @category Function\n * @param {Function} fn The function to curry.\n * @return {Function} The curried function.\n */\n\n\nfunction _curry2(fn) {\n  return function f2(a, b) {\n    switch (arguments.length) {\n      case 0:\n        return f2;\n      case 1:\n        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n          return fn(a, _b);\n        });\n      default:\n        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n          return fn(_a, b);\n        }) : _isPlaceholder(b) ? _curry1(function (_b) {\n          return fn(a, _b);\n        }) : fn(a, b);\n    }\n  };\n}\nmodule.exports = _curry2;","var _arity = /*#__PURE__*/require('./internal/_arity');\n\nvar _curry1 = /*#__PURE__*/require('./internal/_curry1');\n\nvar _curry2 = /*#__PURE__*/require('./internal/_curry2');\n\nvar _curryN = /*#__PURE__*/require('./internal/_curryN');\n\n/**\n * Returns a curried equivalent of the provided function, with the specified\n * arity. The curried function has two unusual capabilities. First, its\n * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *\n * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n * \"gaps\", allowing partial application of any combination of arguments,\n * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n * the following are equivalent:\n *\n *   - `g(1, 2, 3)`\n *   - `g(_, 2, 3)(1)`\n *   - `g(_, _, 3)(1)(2)`\n *   - `g(_, _, 3)(1, 2)`\n *   - `g(_, 2)(1)(3)`\n *   - `g(_, 2)(1, 3)`\n *   - `g(_, 2)(_, 3)(1)`\n *\n * @func\n * @memberOf R\n * @since v0.5.0\n * @category Function\n * @sig Number -> (* -> a) -> (* -> a)\n * @param {Number} length The arity for the returned function.\n * @param {Function} fn The function to curry.\n * @return {Function} A new, curried function.\n * @see R.curry\n * @example\n *\n *      var sumArgs = (...args) => R.sum(args);\n *\n *      var curriedAddFourNumbers = R.curryN(4, sumArgs);\n *      var f = curriedAddFourNumbers(1, 2);\n *      var g = f(3);\n *      g(4); //=> 10\n */\n\n\nvar curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {\n  if (length === 1) {\n    return _curry1(fn);\n  }\n  return _arity(length, _curryN(length, [], fn));\n});\nmodule.exports = curryN;","'use strict';\n\nvar curryN = require('ramda/src/curryN');\n\n// Utility\nfunction isFunction(obj) {\n  return !!(obj && obj.constructor && obj.call && obj.apply);\n}\nfunction trueFn() { return true; }\n\n// Globals\nvar toUpdate = [];\nvar inStream;\nvar order = [];\nvar orderNextIdx = -1;\nvar flushingUpdateQueue = false;\nvar flushingStreamValue = false;\n\nfunction flushing() {\n  return flushingUpdateQueue || flushingStreamValue;\n}\n\n\n/** @namespace */\nvar flyd = {}\n\n// /////////////////////////// API ///////////////////////////////// //\n\n/**\n * Creates a new stream\n *\n * __Signature__: `a -> Stream a`\n *\n * @name flyd.stream\n * @param {*} initialValue - (Optional) the initial value of the stream\n * @return {stream} the stream\n *\n * @example\n * var n = flyd.stream(1); // Stream with initial value `1`\n * var s = flyd.stream(); // Stream with no initial value\n */\nflyd.stream = function(initialValue) {\n  var endStream = createDependentStream([], trueFn);\n  var s = createStream();\n  s.end = endStream;\n  s.fnArgs = [];\n  endStream.listeners.push(s);\n  if (arguments.length > 0) s(initialValue);\n  return s;\n}\n// fantasy-land Applicative\nflyd.stream['fantasy-land/of'] = flyd.stream.of = flyd.stream;\n\n\n/**\n * Create a new dependent stream\n *\n * __Signature__: `(...Stream * -> Stream b -> b) -> [Stream *] -> Stream b`\n *\n * @name flyd.combine\n * @param {Function} fn - the function used to combine the streams\n * @param {Array<stream>} dependencies - the streams that this one depends on\n * @return {stream} the dependent stream\n *\n * @example\n * var n1 = flyd.stream(0);\n * var n2 = flyd.stream(0);\n * var max = flyd.combine(function(n1, n2, self, changed) {\n *   return n1() > n2() ? n1() : n2();\n * }, [n1, n2]);\n */\nflyd.combine = curryN(2, combine);\nfunction combine(fn, streams) {\n  var i, s, deps, depEndStreams;\n  var endStream = createDependentStream([], trueFn);\n  deps = []; depEndStreams = [];\n  for (i = 0; i < streams.length; ++i) {\n    if (streams[i] !== undefined) {\n      deps.push(streams[i]);\n      if (streams[i].end !== undefined) depEndStreams.push(streams[i].end);\n    }\n  }\n  s = createDependentStream(deps, fn);\n  s.depsChanged = [];\n  s.fnArgs = s.deps.concat([s, s.depsChanged]);\n  s.end = endStream;\n  endStream.listeners.push(s);\n  addListeners(depEndStreams, endStream);\n  endStream.deps = depEndStreams;\n  updateStream(s);\n  return s;\n}\n\n/**\n * Returns `true` if the supplied argument is a Flyd stream and `false` otherwise.\n *\n * __Signature__: `* -> Boolean`\n *\n * @name flyd.isStream\n * @param {*} value - the value to test\n * @return {Boolean} `true` if is a Flyd streamn, `false` otherwise\n *\n * @example\n * var s = flyd.stream(1);\n * var n = 1;\n * flyd.isStream(s); //=> true\n * flyd.isStream(n); //=> false\n */\nflyd.isStream = function(stream) {\n  return isFunction(stream) && 'hasVal' in stream;\n}\n\n/**\n * Invokes the body (the function to calculate the value) of a dependent stream\n *\n * By default the body of a dependent stream is only called when all the streams\n * upon which it depends has a value. `immediate` can circumvent this behaviour.\n * It immediately invokes the body of a dependent stream.\n *\n * __Signature__: `Stream a -> Stream a`\n *\n * @name flyd.immediate\n * @param {stream} stream - the dependent stream\n * @return {stream} the same stream\n *\n * @example\n * var s = flyd.stream();\n * var hasItems = flyd.immediate(flyd.combine(function(s) {\n *   return s() !== undefined && s().length > 0;\n * }, [s]);\n * console.log(hasItems()); // logs `false`. Had `immediate` not been\n *                          // used `hasItems()` would've returned `undefined`\n * s([1]);\n * console.log(hasItems()); // logs `true`.\n * s([]);\n * console.log(hasItems()); // logs `false`.\n */\nflyd.immediate = function(s) {\n  if (s.depsMet === false) {\n    s.depsMet = true;\n    updateStream(s);\n  }\n  return s;\n}\n\n/**\n * Changes which `endsStream` should trigger the ending of `s`.\n *\n * __Signature__: `Stream a -> Stream b -> Stream b`\n *\n * @name flyd.endsOn\n * @param {stream} endStream - the stream to trigger the ending\n * @param {stream} stream - the stream to be ended by the endStream\n * @param {stream} the stream modified to be ended by endStream\n *\n * @example\n * var n = flyd.stream(1);\n * var killer = flyd.stream();\n * // `double` ends when `n` ends or when `killer` emits any value\n * var double = flyd.endsOn(flyd.merge(n.end, killer), flyd.combine(function(n) {\n *   return 2 * n();\n * }, [n]);\n*/\nflyd.endsOn = function(endS, s) {\n  detachDeps(s.end);\n  endS.listeners.push(s.end);\n  s.end.deps.push(endS);\n  return s;\n}\n\n/**\n * Map a stream\n *\n * Returns a new stream consisting of every value from `s` passed through\n * `fn`. I.e. `map` creates a new stream that listens to `s` and\n * applies `fn` to every new value.\n * __Signature__: `(a -> result) -> Stream a -> Stream result`\n *\n * @name flyd.map\n * @param {Function} fn - the function that produces the elements of the new stream\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = flyd.map(function(n) { return n*n; }, numbers);\n */\n// Library functions use self callback to accept (null, undefined) update triggers.\nfunction map(f, s) {\n  return combine(function(s, self) { self(f(s.val)); }, [s]);\n}\nflyd.map = curryN(2, map)\n\n/**\n * Chain a stream\n *\n * also known as flatMap\n *\n * Where `fn` returns a stream this function will flatten the resulting streams.\n * Every time `fn` is called the context of the returned stream will \"switch\" to that stream.\n *\n * __Signature__: `(a -> Stream b) -> Stream a -> Stream b`\n *\n * @name flyd.chain\n * @param {Function} fn - the function that produces the streams to be flattened\n * @param {stream} stream - the stream to map\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var filter = flyd.stream('who');\n * var items = flyd.chain(function(filter){\n *   return flyd.stream(findUsers(filter));\n * }, filter);\n */\nflyd.chain = curryN(2, chain);\n\n/**\n * Apply a stream\n *\n * Applies the value in `s2` to the function in `s1`.\n *\n * __Signature__: `Stream (a -> b) -> Stream a -> Stream b`\n *\n * @name flyd.ap\n * @param {stream} s1 - The value to be applied\n * @param {stream} s2 - The function expecting the value\n * @return {stream} a new stream with the mapped values\n *\n * @example\n * var add = stream(a => b => a + b)\n * var n1 = stream(1)\n * var n2 = stream(2)\n *\n * var added = flyd.ap(n2, flyd.ap(n1, add)) // stream(3)\n * // can also be written using pipe\n * var added_pipe = add\n *   .pipe(ap(n1))\n *   .pipe(ap(n2));\n * added_pipe() // 3\n */\nflyd.ap = curryN(2, ap);\n\n/**\n * Listen to stream events\n *\n * Similar to `map` except that the returned stream is empty. Use `on` for doing\n * side effects in reaction to stream changes. Use the returned stream only if you\n * need to manually end it.\n *\n * __Signature__: `(a -> result) -> Stream a -> Stream undefined`\n *\n * @name flyd.on\n * @param {Function} cb - the callback\n * @param {stream} stream - the stream\n * @return {stream} an empty stream (can be ended)\n */\nflyd.on = curryN(2, function(f, s) {\n  return combine(function(s) { f(s.val); }, [s]);\n})\n\n/**\n * Creates a new stream with the results of calling the function on every incoming\n * stream with and accumulator and the incoming value.\n *\n * __Signature__: `(a -> b -> a) -> a -> Stream b -> Stream a`\n *\n * @name flyd.scan\n * @param {Function} fn - the function to call\n * @param {*} val - the initial value of the accumulator\n * @param {stream} stream - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var numbers = flyd.stream();\n * var sum = flyd.scan(function(sum, n) { return sum+n; }, 0, numbers);\n * numbers(2)(3)(5);\n * sum(); // 10\n */\nflyd.scan = curryN(3, function(f, acc, s) {\n  var ns = combine(function(s, self) {\n    self(acc = f(acc, s.val));\n  }, [s]);\n  if (!ns.hasVal) ns(acc);\n  return ns;\n});\n\n/**\n * Creates a new stream down which all values from both `stream1` and `stream2`\n * will be sent.\n *\n * __Signature__: `Stream a -> Stream a -> Stream a`\n *\n * @name flyd.merge\n * @param {stream} source1 - one stream to be merged\n * @param {stream} source2 - the other stream to be merged\n * @return {stream} a stream with the values from both sources\n *\n * @example\n * var btn1Clicks = flyd.stream();\n * button1Elm.addEventListener(btn1Clicks);\n * var btn2Clicks = flyd.stream();\n * button2Elm.addEventListener(btn2Clicks);\n * var allClicks = flyd.merge(btn1Clicks, btn2Clicks);\n */\nflyd.merge = curryN(2, function(s1, s2) {\n  var s = flyd.immediate(combine(function(s1, s2, self, changed) {\n    if (changed[0]) {\n      self(changed[0]());\n    } else if (s1.hasVal) {\n      self(s1.val);\n    } else if (s2.hasVal) {\n      self(s2.val);\n    }\n  }, [s1, s2]));\n  flyd.endsOn(combine(function() {\n    return true;\n  }, [s1.end, s2.end]), s);\n  return s;\n});\n\n/**\n * Creates a new stream resulting from applying `transducer` to `stream`.\n *\n * __Signature__: `Transducer -> Stream a -> Stream b`\n *\n * @name flyd.transduce\n * @param {Transducer} xform - the transducer transformation\n * @param {stream} source - the stream source\n * @return {stream} the new stream\n *\n * @example\n * var t = require('transducers.js');\n *\n * var results = [];\n * var s1 = flyd.stream();\n * var tx = t.compose(t.map(function(x) { return x * 2; }), t.dedupe());\n * var s2 = flyd.transduce(tx, s1);\n * flyd.combine(function(s2) { results.push(s2()); }, [s2]);\n * s1(1)(1)(2)(3)(3)(3)(4);\n * results; // => [2, 4, 6, 8]\n */\nflyd.transduce = curryN(2, function(xform, source) {\n  xform = xform(new StreamTransformer());\n  return combine(function(source, self) {\n    var res = xform['@@transducer/step'](undefined, source.val);\n    if (res && res['@@transducer/reduced'] === true) {\n      self.end(true);\n      return res['@@transducer/value'];\n    } else {\n      return res;\n    }\n  }, [source]);\n});\n\n/**\n * Returns `fn` curried to `n`. Use this function to curry functions exposed by\n * modules for Flyd.\n *\n * @name flyd.curryN\n * @function\n * @param {Integer} arity - the function arity\n * @param {Function} fn - the function to curry\n * @return {Function} the curried function\n *\n * @example\n * function add(x, y) { return x + y; };\n * var a = flyd.curryN(2, add);\n * a(2)(4) // => 6\n */\nflyd.curryN = curryN\n\n/**\n * Returns a new stream identical to the original except every\n * value will be passed through `f`.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream a`: `(a -> b) -> Stream b`\n *\n * @name stream.map\n * @param {Function} function - the function to apply\n * @return {stream} a new stream with the values mapped\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.map(function(n) { return n*n; });\n */\nfunction boundMap(f) { return map(f, this); }\n\n/**\n * Returns the result of applying function `fn` to this stream\n *\n * __Signature__: Called bound to `Stream a`: `(a -> Stream b) -> Stream b`\n *\n * @name stream.pipe\n * @param {Function} fn - the function to apply\n * @return {stream} A new stream\n *\n * @example\n * var numbers = flyd.stream(0);\n * var squaredNumbers = numbers.pipe(flyd.map(function(n){ return n*n; }));\n */\nfunction operator_pipe(f) { return f(this) }\n\nfunction boundChain(f) {\n  return chain(f, this);\n}\n\nfunction chain(f, s) {\n  // Internal state to end flat map stream\n  var flatEnd = flyd.stream(1);\n  var internalEnded = flyd.on(function() {\n    var alive = flatEnd() - 1;\n    flatEnd(alive);\n    if (alive <= 0) {\n      flatEnd.end(true);\n    }\n  });\n\n  internalEnded(s.end);\n  var last = flyd.stream();\n  var flatStream = flyd.combine(function(s, own) {\n    last.end(true)\n    // Our fn stream makes streams\n    var newS = f(s());\n    flatEnd(flatEnd() + 1);\n    internalEnded(newS.end);\n\n    // Update self on call -- newS is never handed out so deps don't matter\n    last = map(own, newS);\n  }, [s]);\n\n  flyd.endsOn(flatEnd.end, flatStream);\n\n  return flatStream;\n}\n\nflyd.fromPromise = function fromPromise(p) {\n  var s = flyd.stream();\n  p.then(function(val) {\n    s(val);\n    s.end(true);\n  });\n  return s;\n}\n\nflyd.flattenPromise = function flattenPromise(s) {\n  return combine(function(s, self) {\n    s().then(self);\n  }, [s])\n}\n\n\n/**\n * Returns a new stream which is the result of applying the\n * functions from `this` stream to the values in `stream` parameter.\n *\n * `this` stream must be a stream of functions.\n *\n * _Note:_ This function is included in order to support the fantasy land\n * specification.\n *\n * __Signature__: Called bound to `Stream (a -> b)`: `a -> Stream b`\n *\n * @name stream.ap\n * @param {stream} stream - the values stream\n * @return {stream} a new stream with the functions applied to values\n *\n * @example\n * var add = flyd.curryN(2, function(x, y) { return x + y; });\n * var numbers1 = flyd.stream();\n * var numbers2 = flyd.stream();\n * var addToNumbers1 = flyd.map(add, numbers1);\n * var added = addToNumbers1.ap(numbers2);\n */\nfunction ap(s2, s1) {\n  return combine(function(s1, s2, self) { self(s1.val(s2.val)); }, [s1, s2]);\n}\n\nfunction boundAp(s2) {\n  return ap(s2, this);\n}\n\n/**\n * @private\n */\nfunction fantasy_land_ap(s1) {\n  return ap(this, s1);\n}\n\n/**\n * Get a human readable view of a stream\n * @name stream.toString\n * @return {String} the stream string representation\n */\nfunction streamToString() {\n  return 'stream(' + this.val + ')';\n}\n\n/**\n * @name stream.end\n * @memberof stream\n * A stream that emits `true` when the stream ends. If `true` is pushed down the\n * stream the parent stream ends.\n */\n\n/**\n * @name stream.of\n * @function\n * @memberof stream\n * Returns a new stream with `value` as its initial value. It is identical to\n * calling `flyd.stream` with one argument.\n *\n * __Signature__: Called bound to `Stream (a)`: `b -> Stream b`\n *\n * @param {*} value - the initial value\n * @return {stream} the new stream\n *\n * @example\n * var n = flyd.stream(1);\n * var m = n.of(1);\n */\n\n// /////////////////////////// PRIVATE ///////////////////////////////// //\n/**\n * @private\n * Create a stream with no dependencies and no value\n * @return {Function} a flyd stream\n */\nfunction createStream() {\n  function s(n) {\n    if (arguments.length === 0) return s.val\n    updateStreamValue(n, s)\n    return s\n  }\n  s.hasVal = false;\n  s.val = undefined;\n  s.updaters = [];\n  s.listeners = [];\n  s.queued = false;\n  s.end = undefined;\n\n  // fantasy-land compatibility\n  s.ap = boundAp;\n  s['fantasy-land/map'] = s.map = boundMap;\n  s['fantasy-land/ap'] = fantasy_land_ap;\n  s['fantasy-land/of'] = s.of = flyd.stream;\n  s['fantasy-land/chain'] = s.chain = boundChain;\n\n  s.pipe = operator_pipe;\n\n  // According to the fantasy-land Applicative specification\n  // Given a value f, one can access its type representative via the constructor property:\n  // `f.constructor.of`\n  s.constructor = flyd.stream;\n\n  s.toJSON = function() {\n    return s.val;\n  }\n  s.toString = streamToString;\n  return s;\n}\n\n/**\n * @private\n * Create a dependent stream\n * @param {Array<stream>} dependencies - an array of the streams\n * @param {Function} fn - the function used to calculate the new stream value\n * from the dependencies\n * @return {stream} the created stream\n */\nfunction createDependentStream(deps, fn) {\n  var s = createStream();\n  s.fn = fn;\n  s.deps = deps;\n  s.depsMet = false;\n  s.depsChanged = deps.length > 0 ? [] : undefined;\n  s.shouldUpdate = false;\n  addListeners(deps, s);\n  return s;\n}\n\n/**\n * @private\n * Check if all the dependencies have values\n * @param {stream} stream - the stream to check depencencies from\n * @return {Boolean} `true` if all dependencies have vales, `false` otherwise\n */\nfunction initialDependenciesMet(stream) {\n  stream.depsMet = stream.deps.every(function(s) {\n    return s.hasVal;\n  });\n  return stream.depsMet;\n}\n\nfunction dependenciesAreMet(stream) {\n  return stream.depsMet === true || initialDependenciesMet(stream);\n}\n\nfunction isEnded(stream) {\n  return stream.end && stream.end.val === true;\n}\n\nfunction listenersNeedUpdating(s) {\n  return s.listeners.some(function(s) { return s.shouldUpdate; });\n}\n\n/**\n * @private\n * Update a dependent stream using its dependencies in an atomic way\n * @param {stream} stream - the stream to update\n */\nfunction updateStream(s) {\n  if (isEnded(s) || !dependenciesAreMet(s)) return;\n  if (inStream !== undefined) {\n    updateLaterUsing(updateStream, s);\n    return;\n  }\n  inStream = s;\n  if (s.depsChanged) s.fnArgs[s.fnArgs.length - 1] = s.depsChanged;\n  var returnVal = s.fn.apply(s.fn, s.fnArgs);\n  if (returnVal !== undefined) {\n    s(returnVal);\n  }\n  inStream = undefined;\n  if (s.depsChanged !== undefined) s.depsChanged = [];\n  s.shouldUpdate = false;\n  if (flushing() === false) flushUpdate();\n  if (listenersNeedUpdating(s)) {\n    if (!flushingStreamValue) s(s.val)\n    else {\n      s.listeners.forEach(function(listener) {\n        if (listener.shouldUpdate) updateLaterUsing(updateStream, listener);\n      });\n    }\n  }\n}\n\n/**\n * @private\n * Update the dependencies of a stream\n * @param {stream} stream\n */\nfunction updateListeners(s) {\n  var i, o, list\n  var listeners = s.listeners;\n  for (i = 0; i < listeners.length; ++i) {\n    list = listeners[i];\n    if (list.end === s) {\n      endStream(list);\n    } else {\n      if (list.depsChanged !== undefined) list.depsChanged.push(s);\n      list.shouldUpdate = true;\n      findDeps(list);\n    }\n  }\n  for (; orderNextIdx >= 0; --orderNextIdx) {\n    o = order[orderNextIdx];\n    if (o.shouldUpdate === true) updateStream(o);\n    o.queued = false;\n  }\n}\n\n/**\n * @private\n * Add stream dependencies to the global `order` queue.\n * @param {stream} stream\n * @see updateDeps\n */\nfunction findDeps(s) {\n  var i\n  var listeners = s.listeners;\n  if (s.queued === false) {\n    s.queued = true;\n    for (i = 0; i < listeners.length; ++i) {\n      findDeps(listeners[i]);\n    }\n    order[++orderNextIdx] = s;\n  }\n}\n\nfunction updateLaterUsing(updater, stream) {\n  toUpdate.push(stream);\n  stream.updaters.push(updater);\n  stream.shouldUpdate = true;\n}\n\n/**\n * @private\n */\nfunction flushUpdate() {\n  flushingUpdateQueue = true;\n  while (toUpdate.length > 0) {\n    var stream = toUpdate.shift();\n    var nextUpdateFn = stream.updaters.shift();\n    if (nextUpdateFn && stream.shouldUpdate) nextUpdateFn(stream);\n  }\n  flushingUpdateQueue = false;\n}\n\n/**\n * @private\n * Push down a value into a stream\n * @param {stream} stream\n * @param {*} value\n */\nfunction updateStreamValue(n, s) {\n  s.val = n;\n  s.hasVal = true;\n  if (inStream === undefined) {\n    flushingStreamValue = true;\n    updateListeners(s);\n    if (toUpdate.length > 0) flushUpdate();\n    flushingStreamValue = false;\n  } else if (inStream === s) {\n    markListeners(s, s.listeners);\n  } else {\n    updateLaterUsing(function(s) { updateStreamValue(n, s); }, s);\n  }\n}\n\n/**\n * @private\n */\nfunction markListeners(s, lists) {\n  var i, list;\n  for (i = 0; i < lists.length; ++i) {\n    list = lists[i];\n    if (list.end !== s) {\n      if (list.depsChanged !== undefined) {\n        list.depsChanged.push(s);\n      }\n      list.shouldUpdate = true;\n    } else {\n      endStream(list);\n    }\n  }\n}\n\n/**\n * @private\n * Add dependencies to a stream\n * @param {Array<stream>} dependencies\n * @param {stream} stream\n */\nfunction addListeners(deps, s) {\n  for (var i = 0; i < deps.length; ++i) {\n    deps[i].listeners.push(s);\n  }\n}\n\n/**\n * @private\n * Removes an stream from a dependency array\n * @param {stream} stream\n * @param {Array<stream>} dependencies\n */\nfunction removeListener(s, listeners) {\n  var idx = listeners.indexOf(s);\n  listeners[idx] = listeners[listeners.length - 1];\n  listeners.length--;\n}\n\n/**\n * @private\n * Detach a stream from its dependencies\n * @param {stream} stream\n */\nfunction detachDeps(s) {\n  for (var i = 0; i < s.deps.length; ++i) {\n    removeListener(s, s.deps[i].listeners);\n  }\n  s.deps.length = 0;\n}\n\n/**\n * @private\n * Ends a stream\n */\nfunction endStream(s) {\n  if (s.deps !== undefined) detachDeps(s);\n  if (s.end !== undefined) detachDeps(s.end);\n}\n\n/**\n * @private\n */\n/**\n * @private\n * transducer stream transformer\n */\nfunction StreamTransformer() { }\nStreamTransformer.prototype['@@transducer/init'] = function() { };\nStreamTransformer.prototype['@@transducer/result'] = function() { };\nStreamTransformer.prototype['@@transducer/step'] = function(s, v) { return v; };\n\nmodule.exports = flyd;\n","const e=Object.assign||((e,t)=>(t&&Object.keys(t).forEach(o=>e[o]=t[o]),e)),t=(e,r,s)=>{const c=typeof s;if(s&&\"object\"===c)if(Array.isArray(s))for(const o of s)r=t(e,r,o);else for(const c of Object.keys(s)){const f=s[c];\"function\"==typeof f?r[c]=f(r[c],o):void 0===f?e&&!isNaN(c)?r.splice(c,1):delete r[c]:null===f||\"object\"!=typeof f||Array.isArray(f)?r[c]=f:\"object\"==typeof r[c]?r[c]=f===r[c]?f:o(r[c],f):r[c]=t(!1,{},f)}else\"function\"===c&&(r=s(r,o));return r},o=(o,...r)=>{const s=Array.isArray(o);return t(s,s?o.slice():e({},o),r)};export default o;\n//# sourceMappingURL=mergerino.min.js.map","import flyd from \"flyd\";\nimport merge from \"mergerino\";\n\nconst { stream, scan } = flyd;\n\nexport type FunctionPatch<T> = (state: T) => T;\nexport type Patch<T> = FunctionPatch<T> | Partial<T>;\n\nexport interface Stream<T> {\n  (): T;\n  (value: T): Stream<T>;\n  map<V>(project: (value: T) => V): Stream<V>;\n  end: Stream<boolean>;\n  val: T;\n}\n\nexport type Store<T> = Stream<T> & {\n  update: Stream<Patch<T>>;\n};\n\nexport const store = <T extends object>(initial: T): Store<T> => {\n  const update = stream<Patch<T>>();\n  const states = scan(\n    (state: T, patch: Patch<T>): T => merge(state, patch),\n    initial,\n    update\n  );\n\n  return Object.assign(states, { update });;\n};\n","const {defineProperties, keys} = Object;\n\nexport {defineProperties, keys};\n","import {keys} from './object.js';\n\nconst accessor = (all, shallow, hook, value, update) => ({\n  configurable: true,\n  get: () => value,\n  set(_) {\n    if (all || _ !== value || (shallow && typeof _ === 'object' && _)) {\n      value = _;\n      if (hook)\n        update.call(this, value);\n      else\n        update.call(this);\n    }\n  }\n});\n\nexport const loop = (props, get, all, shallow, useState, update) => {\n  const desc = {};\n  const hook = useState !== noop;\n  const args = [all, shallow, hook];\n  for (let ke = keys(props), y = 0; y < ke.length; y++) {\n    const value = get(props, ke[y]);\n    const extras = hook ? useState(value) : [value, useState];\n    if (update)\n      extras[1] = update;\n    desc[ke[y]] = accessor.apply(null, args.concat(extras));\n  }\n  return desc;\n};\n\nexport const noop = () => {};\n","import { render, html } from \"uhtml\";\nimport css from \"plain-tag\";\nimport type { Store, Stream, Patch } from \"./state\";\nimport { store } from \"./state\";\n// @ts-ignore\nimport DOMHandler from \"reactive-props/esm/dom.js\";\n\nconst observe = DOMHandler({ dom: true });\n\ninterface Ref<T extends HTMLElement> {\n  current: T | null\n}\n\ntype Slots = { default: Node[] } & { [key: string]: Node }\n\ntype CustomHandlers = Record<\n  `handle_${keyof HTMLElementEventMap}`,\n  EventListener\n>;\n\ninterface DefinitionCallbacks {\n  /**\n   * Invoked each time the custom element is appended into a document-connected\n   * element. This will happen each time the node is moved, and may happen\n   * before the element's contents have been fully parsed.\n   */\n  connected?(): void;\n\n  /**\n   * Invoked each time the custom element is disconnected from the document's\n   * DOM.\n   */\n  disconnected?(): void;\n\n  /**\n   * Invoked *after* the component is connected and guarantees the element's\n   * contents hev been fully parsed. At this point `refs` and `this.slots`\n   * should work properly.\n   */\n  ready?(): void;\n\n  /**\n   * Invoked every time a store is updated or an attribute changes.\n   */\n  update?(): any;\n\n  /**\n   * Invoked right after a component update. The returned value will be\n   * used to render the component's contents.\n   */\n  render?(): ReturnType<typeof html>;\n\n  performRender(): void;\n\n  handleEvent(event: Event): void;\n\n  /**\n   * Subscribes to a store.\n   * Store updates will trigger a component update. If multiple consecutive\n   * store updates happen, a single component update is guaranteed to be run\n   * in the next microtask.\n   */\n  useStore<T>(store: Store<T>): Store<T>;\n\n  /**\n   * Holds a map of slots found in the element's dom once it's ready.\n   *\n   * Consider the following markup:\n   * ```html\n   * <my-element>\n   *   Hello world!\n   *   <button slot=\"action\">Press me!</button>\n   *   <p>I'm a paragraph!</p>\n   * </my-element>\n   * ```\n   * The element's `this.slots` will look like this:\n   * ```js\n   * {\n   *   default: [\n   *     #text \"Hello world!\"\n   *     <p>I'm a paragraph!</p>\n   *   ],\n   *   action: <button slot=\"action\">Press me!</button>\n   * }\n   * ```\n   */\n  readonly slots: Slots;\n\n  readonly props: Record<string, any>;\n}\n\nexport interface Definition extends HTMLElement, Partial<CustomHandlers>, DefinitionCallbacks { };\n\nexport interface DefinitionConstructor {\n  new(...params: any[]): Definition;\n  css?(tag: string): string;\n}\n\nexport interface AugmentedDefinition extends HTMLElement, Partial<CustomHandlers>, Required<DefinitionCallbacks> {\n  performRender: () => void;\n}\n\nexport interface AugmentedDefinitionConstructor extends DefinitionConstructor {\n  new(...params: any[]): AugmentedDefinition;\n}\n\n/**\n * Creates a reference to be used in templates.\n * If an element has a `ref=${my_ref}` attribute in a template, the\n * `my_ref.current` will be set to that element once it's rendered.\n */\nconst ref = <T extends HTMLElement>(): Ref<T> => ({ current: null });\n\n/**\n * Tricks typescript so it doesn't complain if you use methods that are added\n * while defining the component.\n *\n * @param superclass The base class to extend, defaults to `HTMLElement`\n */\nconst Component = <T extends CustomElementConstructor>(superclass: T = HTMLElement as T): DefinitionConstructor => {\n  return superclass as unknown as DefinitionConstructor;\n}\n\nconst active_streams = new WeakMap<object, Stream<any>[]>();\nconst ready_elements = new WeakSet();\nlet updates_schedule = new Set<Definition>();\nlet scheduled_renders = new WeakMap();\n\n/**\n * Defines a custom element component. I will create the definition only once,\n * so subsequent attempts to define an already defined element will result in a\n * noop.\n *\n * @param tag The custom element tag\n * @param definition The custom element definition\n * @param opts\n */\nconst define = (tag: string, definition: DefinitionConstructor, opts: ElementDefinitionOptions = {}): AugmentedDefinitionConstructor => {\n\n  const Class = class extends definition {\n\n    constructor() {\n      super();\n      if (this.props) {\n        Reflect.set(this, \"props\", observe(this, this.props, () => schedule_update(this)))\n      }\n    }\n\n    connectedCallback() {\n      this.connected();\n\n      this.dispatchEvent(new CustomEvent(\"connected\"));\n\n      setTimeout(() => this.ready());\n    }\n\n    connected() {\n      if (super.connected) super.connected();\n    }\n\n    disconnected() {\n      if (super.disconnected) {\n        super.disconnected();\n      }\n    }\n\n    ready() {\n      load_slots(this);\n\n      if (super.ready) {\n        super.ready();\n      }\n\n      ready_elements.add(this)\n\n      this.dispatchEvent(new CustomEvent(\"ready\"));\n\n      schedule_update(this);\n    }\n\n    disconnectedCallback() {\n      active_streams.get(this)?.forEach(stream => {\n        stream.end(true);\n      });\n\n      active_streams.delete(this);\n      ready_elements.delete(this);\n\n      this.disconnected();\n\n      this.dispatchEvent(new CustomEvent(\"disconnected\"));\n    }\n\n    update() {\n      if (super.update)\n        super.update();\n\n      this.dispatchEvent(new CustomEvent(\"updated\"));\n\n      this.schedule_render();\n    }\n\n    private schedule_render() {\n      if (scheduled_renders.has(this))\n        cancelAnimationFrame(scheduled_renders.get!(this));\n\n      scheduled_renders.set(this,\n        requestAnimationFrame(() => {\n          scheduled_renders.delete(this);\n          this.performRender();\n        })\n      )\n    }\n\n    performRender() {\n      if (super.render) {\n        render(this, super.render());\n      }\n\n      this.dispatchEvent(new CustomEvent(\"rendered\"));\n    }\n\n    handleEvent(event: Event) {\n      /* istanbul ignore next */\n      Reflect.get(this, `handle_${event.type}`)(event);\n    }\n\n    useStore<T>(store: Store<T>): Store<T> {\n      return useStore(this, store);\n    }\n  } as AugmentedDefinitionConstructor;\n\n  if (!customElements.get(tag)) customElements.define(tag, Class, opts)\n\n  if (definition.css) {\n    const style = document.createElement(\"style\");\n    const selector = opts.extends ? `${opts.extends}[is=${tag}]` : tag;\n    style.textContent = definition.css(selector);\n    document.head.appendChild(style);\n  }\n\n  return Class;\n}\n\nconst run_schedule = () => {\n  const previous = updates_schedule;\n  updates_schedule = new Set();\n  previous.forEach(element => {\n    element.update?.();\n  });\n}\n\nconst schedule_update = (element: Definition) => {\n  if (!updates_schedule.has(element)) {\n    updates_schedule.add(element);\n\n    if (updates_schedule.size === 1) {\n      wait(run_schedule);\n    }\n  }\n}\n\nconst wait = (callback: Function) => {\n  (typeof queueMicrotask === 'function')\n    ? queueMicrotask(callback as VoidFunction)\n    : new Promise<void>(r => r()).then(callback as VoidFunction);\n}\n\n/**\n * Holds the elements that have already loaded their slots.\n * The connected callback runs when the node is first discovered and also when\n * it's moved, so we shouhld only load slots the first time. This also avoids\n * the `Failed to execute 'insertBefore' on 'Node': The node before which the\n * new node is to be inserted is not a child of this node` error thrown by uhtml\n * when we reload slots after moving the element and trying to rerender\n * afterwards. I'm not sure if this is a uhtml bug or my own stupidity.\n */\nconst ready_slots = new WeakSet();\nconst load_slots = (element: Definition) => {\n  // Find slots\n  if (!ready_slots.has(element)) {\n    const slots = get_slots_in(element);\n    Reflect.set(element, \"slots\", slots);\n    ready_slots.add(element);\n  }\n}\n\nconst get_slots_in = (element: Node): Slots => {\n  let default_slots: Node[] = [];\n  let slots: Record<string, Node> = {};\n  for (let el of Array.from(element.childNodes)) {\n    if (el instanceof HTMLTemplateElement) return get_slots_in(el.content);\n\n    const slotName = (el instanceof Element) ? el.getAttribute('slot') : null;\n\n    if (slotName) {\n      slots[slotName] = el\n    } else {\n      default_slots.push(el);\n    }\n  };\n\n  return { default: default_slots, ...slots } as Slots;\n}\n\n/**\n * Subscribe to changes in the store state and triggers a component update.\n * Subscriptions are cleaned up when the component is disconnected.\n */\nconst useStore = <T>(element: Definition, store: Store<T>): Store<T> => {\n  const streams = active_streams.get(element) || [];\n  const updater = store.map(() => {\n    // Only update the component once it's ready, otherwise we will trigger an\n    // update if we're subscribing in a connected or ready callback.\n    if (ready_elements.has(element)) schedule_update(element);\n  });\n  streams.push(updater);\n  active_streams.set(element, streams);\n\n  return store;\n}\n\nexport { Component, define, css, html, ref, store, useStore };\nexport type { Patch, Ref, Store, Stream };\n","import {defineProperties} from './object.js';\nimport {loop, noop} from './utils.js';\n\nexport default ({\n  all = false,\n  shallow = true,\n  useState = noop,\n  getAttribute = (element, key) => element.getAttribute(key)\n} = {}) => (element, props, update) => {\n  const value = (props, key) => {\n    let result = props[key], type = typeof result;\n    if (element.hasOwnProperty(key)) {\n      result = element[key];\n      delete element[key];\n    }\n    else if (element.hasAttribute(key)) {\n      result = getAttribute(element, key);\n      if (type == 'number')\n        result = +result;\n      else if (type == 'boolean')\n        result = !/^(?:false|0|)$/.test(result);\n    }\n    return result;\n  };\n  const desc = loop(props, value, all, shallow, useState, update);\n  return defineProperties(element, desc);\n};\n"],"names":["_","get","key","set","value","attr","empty","node","notNode","selfClosing","trimEnd","isNode","template","i","test","regular","original","name","extra","replace","isArray","Array","indexOf","slice","diffable","operation","nodeType","firstChild","lastChild","range","document","createRange","setStartAfter","setEndAfter","deleteContents","remove","valueOf","createContent","FRAGMENT","TEMPLATE","createHTML","create","html","innerHTML","content","childNodes","selector","RegExp","$1","querySelectorAll","append","markup","type","createSVG","root","length","appendChild","element","createDocumentFragment","createElementNS","svg","reducePath","createPath","path","parentNode","push","call","createTreeWalker","importNode","isImportNodeLengthWrong","createFragment","text","createWalker","fragment","diff","comment","oldNodes","newNodes","a","b","before","bLength","aEnd","bEnd","aStart","bStart","map","insertBefore","has","removeChild","nextSibling","Map","index","sequence","replaceChild","udomdiff","handlers","options","reduceRight","this","oldValue","nodes","anyContent","newValue","textContent","createTextNode","String","handleAnything","current","ref","values","removeAttribute","setAttribute","aria","dataset","data","setter","toLowerCase","info","removeEventListener","addEventListener","event","orphan","attributeNode","createAttributeNS","removeAttributeNode","setAttributeNodeNS","attribute","handleAttribute","cache","umap","WeakMap","unroll","unrollValues","entry","updates","prefix","chunk","$2","output","join","trim","instrument","tw","search","nextNode","hasAttribute","getAttribute","tagName","mapTemplate","mapUpdates","wire","createEntry","ELEMENT_NODE","[object Object]","persistent","stack","hole","Hole","splice","defineProperties","Object","tag","keyed","for","id","memo","fixed","t","s","l","arguments","n","fn","apply","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","Error","f1","_isPlaceholder","_curryN","received","combined","argsIdx","left","combinedIdx","result","_arity","f2","_curry1","_b","_a","_curry2","trueFn","inStream","toUpdate","order","orderNextIdx","flushingUpdateQueue","flushingStreamValue","flyd","combine","streams","deps","depEndStreams","endStream","createDependentStream","undefined","end","depsChanged","fnArgs","concat","listeners","addListeners","updateStream","f","self","val","boundMap","operator_pipe","boundChain","chain","flatEnd","stream","internalEnded","on","alive","last","flatStream","own","newS","endsOn","ap","s2","s1","boundAp","fantasy_land_ap","streamToString","createStream","updateStreamValue","hasVal","updaters","queued","of","pipe","constructor","toJSON","toString","depsMet","shouldUpdate","isEnded","every","initialDependenciesMet","dependenciesAreMet","returnVal","flushUpdate","some","listenersNeedUpdating","forEach","listener","updateLaterUsing","findDeps","updater","shift","nextUpdateFn","o","list","updateListeners","lists","markListeners","removeListener","idx","detachDeps","StreamTransformer","initialValue","curryN","isStream","obj","immediate","endS","scan","acc","ns","merge","changed","transduce","xform","source","res","fromPromise","p","then","flattenPromise","prototype","v","e","assign","keys","r","c","isNaN","store","initial","update","states","state","patch","accessor","all","shallow","hook","configurable","noop","observe","useState","props","desc","args","ke","y","extras","loop","hasOwnProperty","DOMHandler","dom","Component","superclass","HTMLElement","active_streams","ready_elements","WeakSet","updates_schedule","Set","scheduled_renders","define","definition","opts","Class","super","Reflect","schedule_update","connectedCallback","connected","dispatchEvent","CustomEvent","setTimeout","ready","disconnected","load_slots","add","disconnectedCallback","delete","schedule_render","cancelAnimationFrame","requestAnimationFrame","performRender","render","where","what","handleEvent","useStore","customElements","css","style","createElement","extends","head","run_schedule","previous","size","wait","callback","queueMicrotask","Promise","ready_slots","slots","get_slots_in","default_slots","el","from","HTMLTemplateElement","slotName","Element","default"],"mappings":"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"}