{"version":3,"file":"index.js","sources":["../../node_modules/umap/esm/index.js","../../node_modules/uparser/esm/index.js","../../node_modules/uarray/esm/index.js","../../node_modules/uwire/esm/index.js","../../node_modules/udomdiff/esm/index.js","../../node_modules/uhandlers/esm/index.js","../../node_modules/@ungap/create-content/esm/index.js","../../node_modules/uhtml/esm/node.js","../../node_modules/uhtml/esm/handlers.js","../../node_modules/uhtml/esm/rabbit.js","../../node_modules/uhtml/esm/index.js","../../node_modules/plain-tag/esm/index.js","../../src/index.ts"],"sourcesContent":["export default _ => ({\n  // About: get: _.get.bind(_)\n  // It looks like WebKit/Safari didn't optimize bind at all,\n  // so that using bind slows it down by 60%.\n  // Firefox and Chrome are just fine in both cases,\n  // so let's use the approach that works fast everywhere 👍\n  get: key => _.get(key),\n  set: (key, value) => (_.set(key, value), value)\n});\n","const attr = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)$/;\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst node = /<[a-z][^>]+$/i;\nconst notNode = />[^<>]*$/;\nconst selfClosing = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/>)/ig;\nconst trimEnd = /\\s+$/;\n\nconst isNode = (template, i) => (\n    0 < i-- && (\n    node.test(template[i]) || (\n      !notNode.test(template[i]) && isNode(template, i)\n    )\n  )\n);\n\nconst regular = (original, name, extra) => empty.test(name) ?\n                  original : `<${name}${extra.replace(trimEnd,'')}></${name}>`;\n\nexport default (template, prefix, svg) => {\n  const text = [];\n  const {length} = template;\n  for (let i = 1; i < length; i++) {\n    const chunk = template[i - 1];\n    text.push(attr.test(chunk) && isNode(template, i) ?\n      chunk.replace(\n        attr,\n        (_, $1, $2) => `${prefix}${i - 1}=${$2 || '\"'}${$1}${$2 ? '' : '\"'}`\n      ) :\n      `${chunk}<!--${prefix}${i - 1}-->`\n    );\n  }\n  text.push(template[length - 1]);\n  const output = text.join('').trim();\n  return svg ? output : output.replace(selfClosing, regular);\n};\n","const {isArray} = Array;\nconst {indexOf, slice} = [];\n\nexport {isArray, indexOf, slice};\n","import {slice} from 'uarray';\n\nconst ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nexport const diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nexport const persistent = fragment => {\n  const {childNodes} = fragment;\n  const {length} = childNodes;\n  if (length < 2)\n    return length ? childNodes[0] : fragment;\n  const nodes = slice.call(childNodes, 0);\n  const firstChild = nodes[0];\n  const lastChild = nodes[length - 1];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== length) {\n        let i = 0;\n        while (i < length)\n          fragment.appendChild(nodes[i++]);\n      }\n      return fragment;\n    }\n  };\n};\n","/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n","import {isArray} from 'uarray';\n\nexport const aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nexport const attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    if (oldValue !== newValue) {\n      oldValue = newValue;\n      if (oldValue == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        attributeNode.value = newValue;\n        if (orphan) {\n          node.setAttributeNodeNS(attributeNode);\n          orphan = false;\n        }\n      }\n    }\n  };\n};\n\nexport const data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nexport const event = (node, name) => {\n  let oldValue, type = name.slice(2);\n  if (!(name in node) && name.toLowerCase() in node)\n    type = type.toLowerCase();\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nexport const ref = node => value => {\n  if (typeof value === 'function')\n    value(node);\n  else\n    value.current = node;\n};\n\nexport const setter = (node, key) => value => {\n  node[key] = value;\n};\n\nexport const text = node => {\n  let oldValue;\n  return newValue => {\n    if (oldValue != newValue) {\n      oldValue = newValue;\n      node.textContent = newValue == null ? '' : newValue;\n    }\n  };\n};\n","/*! (c) Andrea Giammarchi - ISC */\nvar createContent = (function (document) {'use strict';\n  var FRAGMENT = 'fragment';\n  var TEMPLATE = 'template';\n  var HAS_CONTENT = 'content' in create(TEMPLATE);\n\n  var createHTML = HAS_CONTENT ?\n    function (html) {\n      var template = create(TEMPLATE);\n      template.innerHTML = html;\n      return template.content;\n    } :\n    function (html) {\n      var content = create(FRAGMENT);\n      var template = create(TEMPLATE);\n      var childNodes = null;\n      if (/^[^\\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)) {\n        var selector = RegExp.$1;\n        template.innerHTML = '<table>' + html + '</table>';\n        childNodes = template.querySelectorAll(selector);\n      } else {\n        template.innerHTML = html;\n        childNodes = template.childNodes;\n      }\n      append(content, childNodes);\n      return content;\n    };\n\n  return function createContent(markup, type) {\n    return (type === 'svg' ? createSVG : createHTML)(markup);\n  };\n\n  function append(root, childNodes) {\n    var length = childNodes.length;\n    while (length--)\n      root.appendChild(childNodes[0]);\n  }\n\n  function create(element) {\n    return element === FRAGMENT ?\n      document.createDocumentFragment() :\n      document.createElementNS('http://www.w3.org/1999/xhtml', element);\n  }\n\n  // it could use createElementNS when hasNode is there\n  // but this fallback is equally fast and easier to maintain\n  // it is also battle tested already in all IE\n  function createSVG(svg) {\n    var content = create(FRAGMENT);\n    var template = create('div');\n    template.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\">' + svg + '</svg>';\n    append(content, template.firstChild.childNodes);\n    return content;\n  }\n\n}(document));\nexport default createContent;\n","import createContent from '@ungap/create-content';\nimport {indexOf} from 'uarray';\n\n// from a generic path, retrieves the exact targeted node\nexport const reducePath = ({childNodes}, i) => childNodes[i];\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nexport const createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    parentNode = node.parentNode;\n  }\n  return path;\n};\n\nconst {createTreeWalker, importNode} = document;\nexport {createTreeWalker, importNode};\n\n// this \"hack\" tells the library if the browser is IE11 or old Edge\nconst isImportNodeLengthWrong = importNode.length != 1;\n\n// IE11 and old Edge discard empty nodes when cloning, potentially\n// resulting in broken paths to find updates. The workaround here\n// is to import once, upfront, the fragment that will be cloned\n// later on, so that paths are retrieved from one already parsed,\n// hence without missing child nodes once re-cloned.\nexport const createFragment = isImportNodeLengthWrong ?\n  (text, type) => importNode.call(\n    document,\n    createContent(text, type),\n    true\n  ) :\n  createContent;\n\n// IE11 and old Edge have a different createTreeWalker signature that\n// has been deprecated in other browsers. This export is needed only\n// to guarantee the TreeWalker doesn't show warnings and, ultimately, works\nexport const createWalker = isImportNodeLengthWrong ?\n  fragment => createTreeWalker.call(document, fragment, 1 | 128, null, false) :\n  fragment => createTreeWalker.call(document, fragment, 1 | 128);\n","import {isArray, slice} from 'uarray';\nimport udomdiff from 'udomdiff';\nimport {aria, attribute, data, event, ref, setter, text} from 'uhandlers';\nimport {diffable} from 'uwire';\n\nimport {reducePath} from './node.js';\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (text)\n            text.textContent = newValue;\n          else\n            text = document.createTextNode(newValue);\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if ('ELEMENT_NODE' in newValue && oldValue !== newValue) {\n          oldValue = newValue;\n          nodes = diff(\n            comment,\n            nodes,\n            newValue.nodeType === 11 ?\n              slice.call(newValue.childNodes) :\n              [newValue]\n          );\n        }\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  if (name === 'ref')\n    return ref(node);\n\n  if (name === 'aria')\n    return aria(node);\n\n  if (name === '.dataset')\n    return data(node);\n\n  if (name.slice(0, 1) === '.')\n    return setter(node, name.slice(1));\n\n  if (name.slice(0, 2) === 'on')\n    return event(node, name);\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nexport function handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n};\n","import umap from 'umap';\nimport instrument from 'uparser';\nimport {isArray} from 'uarray';\nimport {persistent} from 'uwire';\n\nimport {handlers} from './handlers.js';\nimport {createFragment, createPath, createWalker, importNode} from './node.js';\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// isµX=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--isµX-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--isµX--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'isµ';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = umap(new WeakMap);\n\nexport const createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const text = instrument(template, prefix, type === 'svg');\n  const content = createFragment(text, type);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createWalker(content);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div isµ0=\"attr\" isµ1=\"other\"><!--isµ2--><style><!--isµ3--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains isµX\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.textContent === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named isµX and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"isµX\")\n      // the isµX attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search),\n          //svg: svg < 0 ? (svg = ('ownerSVGElement' in node ? 1 : 0)) : svg\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style or a textarea one, check its content\n      // and if it is <!--isµX--> then update tex-only this node\n      if (\n        /^(?:style|textarea)$/i.test(node.tagName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        node.textContent = '';\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = importNode.call(document, content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nexport const unroll = (info, {type, template, values}) => {\n  const {length} = values;\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  unrollValues(info, values, length);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values, length) => {\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(\n        stack[i] || (stack[i] = createCache()),\n        hole,\n        hole.length\n      );\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nexport function Hole(type, template, values) {\n  this.type = type;\n  this.template = template;\n  this.values = values;\n};\n","import umap from 'umap';\nimport {Hole, createCache, unroll} from './rabbit.js';\n\nconst {create, defineProperties} = Object;\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = umap(new WeakMap);\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return defineProperties(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      for: {\n        // keyed operations need a reference object, usually the parent node\n        // which is showing keyed results, and optionally a unique id per each\n        // related node, handy with JSON results and mutable list of objects\n        // that usually carry a unique identifier\n        value(ref, id) {\n          const memo = keyed.get(ref) || keyed.set(ref, create(null));\n          return memo[id] || (memo[id] = fixed(createCache()));\n        }\n      },\n      node: {\n        // it is possible to create one-off content out of the box via node tag\n        // this might return the single created node, or a fragment with all\n        // nodes present at the root level and, of course, their child nodes\n        value: (template, ...values) => unroll(\n          createCache(),\n          {type, template, values}\n        ).valueOf()\n      }\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache = umap(new WeakMap);\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache.get(where) || cache.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    where.textContent = '';\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.appendChild(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nexport {Hole, render, html, svg};\n","export default function (t) {\n  for (var s = t[0], i = 1, l = arguments.length; i < l; i++)\n    s += arguments[i] + t[i];\n  return s;\n};\n","import { render, html } from \"uhtml\";\nimport css from \"plain-tag\";\nimport type { store, Store, Stream } from \"./state\";\n\nexport interface Ref<T extends HTMLElement> {\n  current: T | null\n}\n\n/**\n * Creates a reference to be used in templates.\n * If an element has a `ref=${my_ref}` attribute in a template, the\n * `my_ref.current` will be set to that element once it's rendered.\n */\nconst ref = <T extends HTMLElement>(): Ref<T> => ({ current: null });\n\ntype Slots = { default: Node[] } & { [key: string]: Node }\n\ntype CustomHandlers = Record<\n  `handle_${keyof HTMLElementEventMap}`,\n  EventListener\n>;\n\ninterface Definition extends HTMLElement, Partial<CustomHandlers> {\n  /**\n   * Invoked each time the custom element is appended into a document-connected\n   * element. This will happen each time the node is moved, and may happen\n   * before the element's contents have been fully parsed.\n   */\n  connected?(): void;\n\n  /**\n   * Invoked each time the custom element is disconnected from the document's\n   * DOM.\n   */\n  disconnected?(): void;\n\n  /**\n   * Invoked *after* the component is connected and guarantees the element's\n   * contents hev been fully parsed. At this point `refs` and `this.slots`\n   * should work properly.\n   */\n  ready?(): void;\n\n  /**\n   * Invoked every time a store is updated or an attribute changes.\n   */\n  update?(): any;\n\n  /**\n   * Invoked right after a component update. The returned value will be\n   * used to render the component's contents.\n   */\n  render?(): ReturnType<typeof html>;\n\n  handleEvent(event: Event): void;\n\n  /**\n   * Subscribes to a store.\n   * Store updates will trigger a component update. If multiple consecutive\n   * store updates happen, a single component update is guaranteed to be run\n   * in the next microtask.\n   */\n  useStore<T>(store: Store<T>): Store<T>;\n\n  /**\n   * Holds a map of slots found in the element's dom once it's ready.\n   *\n   * Consider the following markup:\n   * ```html\n   * <my-element>\n   *   Hello world!\n   *   <button slot=\"action\">Press me!</button>\n   *   <p>I'm a paragraph!</p>\n   * </my-element>\n   * ```\n   * The element's `this.slots` will look like this:\n   * ```js\n   * {\n   *   default: [\n   *     #text \"Hello world!\"\n   *     <p>I'm a paragraph!</p>\n   *   ],\n   *   action: <button slot=\"action\">Press me!</button>\n   * }\n   * ```\n   */\n  readonly slots: Slots;\n};\n\ninterface DefinitionConstructor {\n  new(...params: any[]): Definition;\n  css?(tag: string): string;\n}\n\nconst extended_constructors = new Map<CustomElementConstructor, DefinitionConstructor>();\n\n/**\n * Creates a class that can be used to define a component with `define`. Since\n * `define` adds behaviour to the component by extending your own definition,\n * typescript will complain if you try to use methods like `useStore` or if you\n * try to use the component's `handleEvent` via `this.addEventListener(type, this)`.\n * This function is specially useful in those cases, it shouldn't be needed if\n * you use vanilla JS.\n *\n * @param superclass The base class to extend, defaults to `HTMLElement`\n */\nconst Component = (superclass: CustomElementConstructor = HTMLElement): DefinitionConstructor => {\n  let existing = extended_constructors.get(superclass);\n  if (existing) {\n    return existing;\n  }\n\n  const extended = class extends superclass {\n    slots!: Slots;\n\n    handleEvent(event: Event) {\n      Reflect.get(this, `handle_${event.type}`)(event);\n    }\n\n    useStore<T>(store: Store<T>): Store<T> {\n      return useStore(this, store);\n    }\n  }\n\n  extended_constructors.set(superclass, extended);\n\n  return extended;\n}\n\nconst active_streams = new WeakMap<object, Stream<any>[]>();\nconst ready_elements = new WeakSet();\nlet updates_schedule = new Set<Definition>();\n\nconst constructors = new Map<DefinitionConstructor, DefinitionConstructor>();\n\n/**\n * Defines a custom element component. I will create the definition only once,\n * so subsequent attempts to define an already defined element will result in a\n * noop.\n *\n * @param tag The custom element tag\n * @param definition The custom element definition\n * @param opts\n */\nconst define = (tag: string, definition: DefinitionConstructor, opts: ElementDefinitionOptions = {}): DefinitionConstructor => {\n\n  const Class = constructors.get(definition) || class extends definition {\n    connectedCallback() {\n      if (super.connected) super.connected();\n\n      this.dispatchEvent(new CustomEvent(\"connected\"));\n\n      setTimeout(() => this.ready());\n    }\n\n    ready() {\n      load_slots(this);\n\n      if (super.ready) {\n        super.ready();\n      }\n\n      ready_elements.add(this)\n\n      this.dispatchEvent(new CustomEvent(\"ready\"));\n\n      schedule_update(this);\n    }\n\n    disconnectedCallback() {\n      active_streams.get(this)?.forEach(stream => {\n        stream.end(true);\n      });\n\n      active_streams.delete(this);\n      ready_elements.delete(this);\n\n      if (super.disconnected) {\n        super.disconnected();\n      }\n\n      this.dispatchEvent(new CustomEvent(\"disconnected\"));\n    }\n\n    update() {\n      if (super.update)\n        super.update();\n      if (this.render) render(this, this.render());\n    }\n\n    handleEvent(event: Event) {\n      if (!super.handleEvent)\n        Reflect.get(this, `handle_${event.type}`)(event);\n      else\n        super.handleEvent(event);\n    }\n\n    useStore<T>(store: Store<T>): Store<T> {\n      return useStore(this, store);\n    }\n  };\n\n  if (!customElements.get(tag)) customElements.define(tag, Class, opts)\n\n  if (definition.css) {\n    const style = document.createElement(\"style\");\n    const selector = opts.extends ? `${opts.extends}[is=${tag}]` : tag;\n    style.textContent = definition.css(selector);\n    document.head.appendChild(style);\n  }\n\n  constructors.set(definition, Class);\n\n  return Class;\n}\n\nconst run_schedule = () => {\n  const previous = updates_schedule;\n  updates_schedule = new Set();\n  previous.forEach(element => {\n    element.update?.();\n  });\n}\n\nconst schedule_update = (element: Definition) => {\n  if (!updates_schedule.has(element)) {\n    updates_schedule.add(element);\n\n    if (updates_schedule.size === 1) {\n      wait(run_schedule);\n    }\n  }\n}\n\nconst wait = (callback: Function) => {\n  (window.queueMicrotask)\n    ? window.queueMicrotask(callback as VoidFunction)\n    : new Promise<void>(r => r()).then(callback as VoidFunction);\n}\n\n/**\n * Holds the elements that have already loaded their slots.\n * The connected callback runs when the node is first discovered and also when\n * it's moved, so we shouhld only load slots the first time. This also avoids\n * the `Failed to execute 'insertBefore' on 'Node': The node before which the\n * new node is to be inserted is not a child of this node` error thrown by uhtml\n * when we reload slots after moving the element and trying to rerender\n * afterwards. I'm not sure if this is a uhtml bug or my own stupidity.\n */\nconst ready_slots = new WeakSet();\nconst load_slots = (element: Definition) => {\n  // Find slots\n  if (!ready_slots.has(element)) {\n    let default_slots: Node[] = [];\n    let slots: Record<string, Node> = {};\n    Array.from(element.childNodes).forEach(el => {\n      const slotName = (el instanceof Element) ? el.getAttribute('slot') : null;\n\n      if (slotName) {\n        slots[slotName] = el\n      } else {\n        default_slots.push(el);\n      }\n    });\n    Reflect.set(element, \"slots\", { default: default_slots, ...slots });\n    ready_slots.add(element);\n  }\n}\n\n/**\n * Subscribe to changes in the store state and triggers a component update.\n * Subscriptions are cleaned up when the component is disconnected.\n */\nconst useStore = <T>(element: Definition, store: Store<T>): Store<T> => {\n  const streams = active_streams.get(element) || [];\n  const updater = store.map(() => {\n    // Only update the component once it's ready, otherwise we will trigger an\n    // update if we're subscribing in a connected or ready callback.\n    if (ready_elements.has(element)) schedule_update(element);\n  });\n  streams.push(updater);\n  active_streams.set(element, streams);\n\n  return store;\n}\n\nexport { Component, define, css, html, ref, store, useStore };\n"],"names":["cache","ref"],"mappings":";;;;AAAA,WAAe,CAAC,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC;AACxB,EAAE,GAAG,EAAE,CAAC,GAAG,EAAE,KAAK,MAAM,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC;AACjD,CAAC,CAAC;;ACRF,MAAM,IAAI,GAAG,+BAA+B,CAAC;AAC7C,MAAM,KAAK,GAAG,6FAA6F,CAAC;AAC5G,MAAM,IAAI,GAAG,eAAe,CAAC;AAC7B,MAAM,OAAO,GAAG,UAAU,CAAC;AAC3B,MAAM,WAAW,GAAG,uCAAuC,CAAC;AAC5D,MAAM,OAAO,GAAG,MAAM,CAAC;AACvB;AACA,MAAM,MAAM,GAAG,CAAC,QAAQ,EAAE,CAAC;AAC3B,IAAI,CAAC,GAAG,CAAC,EAAE;AACX,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AAC1B,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;AACvD,KAAK;AACL,GAAG;AACH,CAAC,CAAC;AACF;AACA,MAAM,OAAO,GAAG,CAAC,QAAQ,EAAE,IAAI,EAAE,KAAK,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;AAC3D,kBAAkB,QAAQ,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;AAC/E;AACA,iBAAe,CAAC,QAAQ,EAAE,MAAM,EAAE,GAAG,KAAK;AAC1C,EAAE,MAAM,IAAI,GAAG,EAAE,CAAC;AAClB,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,QAAQ,CAAC;AAC5B,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;AACnC,IAAI,MAAM,KAAK,GAAG,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AAClC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;AACrD,MAAM,KAAK,CAAC,OAAO;AACnB,QAAQ,IAAI;AACZ,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,EAAE,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC;AAC5E,OAAO;AACP,MAAM,CAAC,EAAE,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;AACxC,KAAK,CAAC;AACN,GAAG;AACH,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;AAClC,EAAE,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;AACtC,EAAE,OAAO,GAAG,GAAG,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;AAC7D,CAAC;;AClCD,MAAM,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC;AACxB,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,GAAG,EAAE;;ACC3B,MAAM,YAAY,GAAG,CAAC,CAAC;AACvB,MAAM,QAAQ,GAAG,GAAG,CAAC;AACrB;AACA,MAAM,MAAM,GAAG,CAAC,CAAC,UAAU,EAAE,SAAS,CAAC,KAAK;AAC5C,EAAE,MAAM,KAAK,GAAG,QAAQ,CAAC,WAAW,EAAE,CAAC;AACvC,EAAE,KAAK,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AAClC,EAAE,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;AAC/B,EAAE,KAAK,CAAC,cAAc,EAAE,CAAC;AACzB,EAAE,OAAO,UAAU,CAAC;AACpB,CAAC,CAAC;AACF;AACO,MAAM,QAAQ,GAAG,CAAC,IAAI,EAAE,SAAS,KAAK,IAAI,CAAC,QAAQ,KAAK,QAAQ;AACvE,GAAG,CAAC,CAAC,GAAG,SAAS,IAAI,CAAC;AACtB,KAAK,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS;AAC9C,KAAK,SAAS,GAAG,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC;AAClD,EAAE,IAAI;AACN,CAAC;AACD;AACO,MAAM,UAAU,GAAG,QAAQ,IAAI;AACtC,EAAE,MAAM,CAAC,UAAU,CAAC,GAAG,QAAQ,CAAC;AAChC,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,UAAU,CAAC;AAC9B,EAAE,IAAI,MAAM,GAAG,CAAC;AAChB,IAAI,OAAO,MAAM,GAAG,UAAU,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC;AAC7C,EAAE,MAAM,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;AAC1C,EAAE,MAAM,UAAU,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;AAC9B,EAAE,MAAM,SAAS,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;AACtC,EAAE,OAAO;AACT,IAAI,YAAY;AAChB,IAAI,QAAQ;AACZ,IAAI,UAAU;AACd,IAAI,SAAS;AACb,IAAI,OAAO,GAAG;AACd,MAAM,IAAI,UAAU,CAAC,MAAM,KAAK,MAAM,EAAE;AACxC,QAAQ,IAAI,CAAC,GAAG,CAAC,CAAC;AAClB,QAAQ,OAAO,CAAC,GAAG,MAAM;AACzB,UAAU,QAAQ,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC3C,OAAO;AACP,MAAM,OAAO,QAAQ,CAAC;AACtB,KAAK;AACL,GAAG,CAAC;AACJ,CAAC;;AC1CD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,MAAM,KAAK;AAClD,EAAE,MAAM,OAAO,GAAG,CAAC,CAAC,MAAM,CAAC;AAC3B,EAAE,IAAI,IAAI,GAAG,CAAC,CAAC,MAAM,CAAC;AACtB,EAAE,IAAI,IAAI,GAAG,OAAO,CAAC;AACrB,EAAE,IAAI,MAAM,GAAG,CAAC,CAAC;AACjB,EAAE,IAAI,MAAM,GAAG,CAAC,CAAC;AACjB,EAAE,IAAI,GAAG,GAAG,IAAI,CAAC;AACjB,EAAE,OAAO,MAAM,GAAG,IAAI,IAAI,MAAM,GAAG,IAAI,EAAE;AACzC;AACA,IAAI,IAAI,IAAI,KAAK,MAAM,EAAE;AACzB;AACA;AACA;AACA;AACA,MAAM,MAAM,IAAI,GAAG,IAAI,GAAG,OAAO;AACjC,SAAS,MAAM;AACf,WAAW,GAAG,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW;AAC7C,UAAU,GAAG,CAAC,CAAC,CAAC,IAAI,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC;AAClC,QAAQ,MAAM,CAAC;AACf,MAAM,OAAO,MAAM,GAAG,IAAI;AAC1B,QAAQ,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AAC3D,KAAK;AACL;AACA,SAAS,IAAI,IAAI,KAAK,MAAM,EAAE;AAC9B,MAAM,OAAO,MAAM,GAAG,IAAI,EAAE;AAC5B;AACA,QAAQ,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;AACvC,UAAU,UAAU,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AACrD,QAAQ,MAAM,EAAE,CAAC;AACjB,OAAO;AACP,KAAK;AACL;AACA,SAAS,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,EAAE;AACtC,MAAM,MAAM,EAAE,CAAC;AACf,MAAM,MAAM,EAAE,CAAC;AACf,KAAK;AACL;AACA,SAAS,IAAI,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE;AAC1C,MAAM,IAAI,EAAE,CAAC;AACb,MAAM,IAAI,EAAE,CAAC;AACb,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;AAC/B,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;AAC/B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,MAAM,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;AAClD,MAAM,UAAU,CAAC,YAAY;AAC7B,QAAQ,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;AAC3B,QAAQ,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW;AACxC,OAAO,CAAC;AACR,MAAM,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;AACxB,KAAK;AACL;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAM,IAAI,CAAC,GAAG,EAAE;AAChB,QAAQ,GAAG,GAAG,IAAI,GAAG,CAAC;AACtB,QAAQ,IAAI,CAAC,GAAG,MAAM,CAAC;AACvB,QAAQ,OAAO,CAAC,GAAG,IAAI;AACvB,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAC7B,OAAO;AACP;AACA,MAAM,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE;AAC9B;AACA,QAAQ,MAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;AACzC;AACA,QAAQ,IAAI,MAAM,GAAG,KAAK,IAAI,KAAK,GAAG,IAAI,EAAE;AAC5C,UAAU,IAAI,CAAC,GAAG,MAAM,CAAC;AACzB;AACA,UAAU,IAAI,QAAQ,GAAG,CAAC,CAAC;AAC3B,UAAU,OAAO,EAAE,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,GAAG,QAAQ,CAAC;AAC/E,YAAY,QAAQ,EAAE,CAAC;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,IAAI,QAAQ,IAAI,KAAK,GAAG,MAAM,CAAC,EAAE;AAC3C,YAAY,MAAM,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;AAC3C,YAAY,OAAO,MAAM,GAAG,KAAK;AACjC,cAAc,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AACjE,WAAW;AACX;AACA;AACA;AACA,eAAe;AACf,YAAY,UAAU,CAAC,YAAY;AACnC,cAAc,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;AACjC,cAAc,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAClC,aAAa,CAAC;AACd,WAAW;AACX,SAAS;AACT;AACA;AACA,UAAU,MAAM,EAAE,CAAC;AACnB,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ,UAAU,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AACrD,KAAK;AACL,GAAG;AACH,EAAE,OAAO,CAAC,CAAC;AACX,CAAC;;AC1JM,MAAM,IAAI,GAAG,IAAI,IAAI,MAAM,IAAI;AACtC,EAAE,KAAK,MAAM,GAAG,IAAI,MAAM,EAAE;AAC5B,IAAI,MAAM,IAAI,GAAG,GAAG,KAAK,MAAM,GAAG,GAAG,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC;AACtD,IAAI,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AAC9B,IAAI,IAAI,KAAK,IAAI,IAAI;AACrB,MAAM,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;AACjC;AACA,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACrC,GAAG;AACH,CAAC,CAAC;AACF;AACO,MAAM,SAAS,GAAG,CAAC,IAAI,EAAE,IAAI,KAAK;AACzC,EAAE,IAAI,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;AAC9B,EAAE,MAAM,aAAa,GAAG,QAAQ,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC/D,EAAE,OAAO,QAAQ,IAAI;AACrB,IAAI,IAAI,QAAQ,KAAK,QAAQ,EAAE;AAC/B,MAAM,QAAQ,GAAG,QAAQ,CAAC;AAC1B,MAAM,IAAI,QAAQ,IAAI,IAAI,EAAE;AAC5B,QAAQ,IAAI,CAAC,MAAM,EAAE;AACrB,UAAU,IAAI,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;AAClD,UAAU,MAAM,GAAG,IAAI,CAAC;AACxB,SAAS;AACT,OAAO;AACP,WAAW;AACX,QAAQ,aAAa,CAAC,KAAK,GAAG,QAAQ,CAAC;AACvC,QAAQ,IAAI,MAAM,EAAE;AACpB,UAAU,IAAI,CAAC,kBAAkB,CAAC,aAAa,CAAC,CAAC;AACjD,UAAU,MAAM,GAAG,KAAK,CAAC;AACzB,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG,CAAC;AACJ,CAAC,CAAC;AACF;AACO,MAAM,IAAI,GAAG,CAAC,CAAC,OAAO,CAAC,KAAK,MAAM,IAAI;AAC7C,EAAE,KAAK,MAAM,GAAG,IAAI,MAAM,EAAE;AAC5B,IAAI,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AAC9B,IAAI,IAAI,KAAK,IAAI,IAAI;AACrB,MAAM,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC;AAC1B;AACA,MAAM,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;AAC3B,GAAG;AACH,CAAC,CAAC;AACF;AACO,MAAM,KAAK,GAAG,CAAC,IAAI,EAAE,IAAI,KAAK;AACrC,EAAE,IAAI,QAAQ,EAAE,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACrC,EAAE,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,WAAW,EAAE,IAAI,IAAI;AACnD,IAAI,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;AAC9B,EAAE,OAAO,QAAQ,IAAI;AACrB,IAAI,MAAM,IAAI,GAAG,OAAO,CAAC,QAAQ,CAAC,GAAG,QAAQ,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;AAClE,IAAI,IAAI,QAAQ,KAAK,IAAI,CAAC,CAAC,CAAC,EAAE;AAC9B,MAAM,IAAI,QAAQ;AAClB,QAAQ,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1D,MAAM,IAAI,QAAQ,GAAG,IAAI,CAAC,CAAC,CAAC;AAC5B,QAAQ,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD,KAAK;AACL,GAAG,CAAC;AACJ,CAAC,CAAC;AACF;AACO,MAAM,GAAG,GAAG,IAAI,IAAI,KAAK,IAAI;AACpC,EAAE,IAAI,OAAO,KAAK,KAAK,UAAU;AACjC,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;AAChB;AACA,IAAI,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC;AACzB,CAAC,CAAC;AACF;AACO,MAAM,MAAM,GAAG,CAAC,IAAI,EAAE,GAAG,KAAK,KAAK,IAAI;AAC9C,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;AACpB,CAAC,CAAC;AACF;AACO,MAAM,IAAI,GAAG,IAAI,IAAI;AAC5B,EAAE,IAAI,QAAQ,CAAC;AACf,EAAE,OAAO,QAAQ,IAAI;AACrB,IAAI,IAAI,QAAQ,IAAI,QAAQ,EAAE;AAC9B,MAAM,QAAQ,GAAG,QAAQ,CAAC;AAC1B,MAAM,IAAI,CAAC,WAAW,GAAG,QAAQ,IAAI,IAAI,GAAG,EAAE,GAAG,QAAQ,CAAC;AAC1D,KAAK;AACL,GAAG,CAAC;AACJ,CAAC;;AChFD;AACA,IAAI,aAAa,IAAI,UAAU,QAAQ,EAAE,CACzC,EAAE,IAAI,QAAQ,GAAG,UAAU,CAAC;AAC5B,EAAE,IAAI,QAAQ,GAAG,UAAU,CAAC;AAC5B,EAAE,IAAI,WAAW,GAAG,SAAS,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC;AAClD;AACA,EAAE,IAAI,UAAU,GAAG,WAAW;AAC9B,IAAI,UAAU,IAAI,EAAE;AACpB,MAAM,IAAI,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AACtC,MAAM,QAAQ,CAAC,SAAS,GAAG,IAAI,CAAC;AAChC,MAAM,OAAO,QAAQ,CAAC,OAAO,CAAC;AAC9B,KAAK;AACL,IAAI,UAAU,IAAI,EAAE;AACpB,MAAM,IAAI,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AACrC,MAAM,IAAI,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AACtC,MAAM,IAAI,UAAU,GAAG,IAAI,CAAC;AAC5B,MAAM,IAAI,qDAAqD,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AAC5E,QAAQ,IAAI,QAAQ,GAAG,MAAM,CAAC,EAAE,CAAC;AACjC,QAAQ,QAAQ,CAAC,SAAS,GAAG,SAAS,GAAG,IAAI,GAAG,UAAU,CAAC;AAC3D,QAAQ,UAAU,GAAG,QAAQ,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;AACzD,OAAO,MAAM;AACb,QAAQ,QAAQ,CAAC,SAAS,GAAG,IAAI,CAAC;AAClC,QAAQ,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC;AACzC,OAAO;AACP,MAAM,MAAM,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;AAClC,MAAM,OAAO,OAAO,CAAC;AACrB,KAAK,CAAC;AACN;AACA,EAAE,OAAO,SAAS,aAAa,CAAC,MAAM,EAAE,IAAI,EAAE;AAC9C,IAAI,OAAO,CAAC,IAAI,KAAK,KAAK,GAAG,SAAS,GAAG,UAAU,EAAE,MAAM,CAAC,CAAC;AAC7D,GAAG,CAAC;AACJ;AACA,EAAE,SAAS,MAAM,CAAC,IAAI,EAAE,UAAU,EAAE;AACpC,IAAI,IAAI,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;AACnC,IAAI,OAAO,MAAM,EAAE;AACnB,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;AACtC,GAAG;AACH;AACA,EAAE,SAAS,MAAM,CAAC,OAAO,EAAE;AAC3B,IAAI,OAAO,OAAO,KAAK,QAAQ;AAC/B,MAAM,QAAQ,CAAC,sBAAsB,EAAE;AACvC,MAAM,QAAQ,CAAC,eAAe,CAAC,8BAA8B,EAAE,OAAO,CAAC,CAAC;AACxE,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE,SAAS,SAAS,CAAC,GAAG,EAAE;AAC1B,IAAI,IAAI,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AACnC,IAAI,IAAI,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;AACjC,IAAI,QAAQ,CAAC,SAAS,GAAG,0CAA0C,GAAG,GAAG,GAAG,QAAQ,CAAC;AACrF,IAAI,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;AACpD,IAAI,OAAO,OAAO,CAAC;AACnB,GAAG;AACH;AACA,CAAC,CAAC,QAAQ,CAAC,CAAC;;ACpDZ;AACO,MAAM,UAAU,GAAG,CAAC,CAAC,UAAU,CAAC,EAAE,CAAC,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC;AAC7D;AACA;AACA;AACA;AACO,MAAM,UAAU,GAAG,IAAI,IAAI;AAClC,EAAE,MAAM,IAAI,GAAG,EAAE,CAAC;AAClB,EAAE,IAAI,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;AAC1B,EAAE,OAAO,UAAU,EAAE;AACrB,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC,CAAC;AACzD,IAAI,IAAI,GAAG,UAAU,CAAC;AACtB,IAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;AACjC,GAAG;AACH,EAAE,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AACF;AACA,MAAM,CAAC,gBAAgB,EAAE,UAAU,CAAC,GAAG,QAAQ,CAAC;AAEhD;AACA;AACA,MAAM,uBAAuB,GAAG,UAAU,CAAC,MAAM,IAAI,CAAC,CAAC;AACvD;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,cAAc,GAAG,uBAAuB;AACrD,EAAE,CAAC,IAAI,EAAE,IAAI,KAAK,UAAU,CAAC,IAAI;AACjC,IAAI,QAAQ;AACZ,IAAI,aAAa,CAAC,IAAI,EAAE,IAAI,CAAC;AAC7B,IAAI,IAAI;AACR,GAAG;AACH,EAAE,aAAa,CAAC;AAChB;AACA;AACA;AACA;AACO,MAAM,YAAY,GAAG,uBAAuB;AACnD,EAAE,QAAQ,IAAI,gBAAgB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC,GAAG,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC;AAC7E,EAAE,QAAQ,IAAI,gBAAgB,CAAC,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC,GAAG,GAAG,CAAC;;ACrChE;AACA,MAAM,IAAI,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,QAAQ,KAAK,QAAQ;AACtD,EAAE,OAAO,CAAC,UAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,QAAQ;AACV,EAAE,QAAQ;AACV,EAAE,QAAQ;AACV,EAAE,OAAO;AACT,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACA,MAAM,cAAc,GAAG,OAAO,IAAI;AAClC,EAAE,IAAI,QAAQ,EAAE,IAAI,EAAE,KAAK,GAAG,EAAE,CAAC;AACjC,EAAE,MAAM,UAAU,GAAG,QAAQ,IAAI;AACjC,IAAI,QAAQ,OAAO,QAAQ;AAC3B;AACA,MAAM,KAAK,QAAQ,CAAC;AACpB,MAAM,KAAK,QAAQ,CAAC;AACpB,MAAM,KAAK,SAAS;AACpB,QAAQ,IAAI,QAAQ,KAAK,QAAQ,EAAE;AACnC,UAAU,QAAQ,GAAG,QAAQ,CAAC;AAC9B,UAAU,IAAI,IAAI;AAClB,YAAY,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC;AACxC;AACA,YAAY,IAAI,GAAG,QAAQ,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;AACrD,UAAU,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;AAC/C,SAAS;AACT,QAAQ,MAAM;AACd;AACA,MAAM,KAAK,QAAQ,CAAC;AACpB,MAAM,KAAK,WAAW;AACtB,QAAQ,IAAI,QAAQ,IAAI,IAAI,EAAE;AAC9B,UAAU,IAAI,QAAQ,IAAI,QAAQ,EAAE;AACpC,YAAY,QAAQ,GAAG,QAAQ,CAAC;AAChC,YAAY,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;AAC7C,WAAW;AACX,UAAU,MAAM;AAChB,SAAS;AACT;AACA,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,EAAE;AAC/B,UAAU,QAAQ,GAAG,QAAQ,CAAC;AAC9B;AACA,UAAU,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC;AACnC,YAAY,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;AAC7C;AACA,eAAe,IAAI,OAAO,QAAQ,CAAC,CAAC,CAAC,KAAK,QAAQ;AAClD,YAAY,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;AACnD;AACA;AACA,YAAY,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;AACzC,UAAU,MAAM;AAChB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAI,cAAc,IAAI,QAAQ,IAAI,QAAQ,KAAK,QAAQ,EAAE;AACjE,UAAU,QAAQ,GAAG,QAAQ,CAAC;AAC9B,UAAU,KAAK,GAAG,IAAI;AACtB,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,QAAQ,CAAC,QAAQ,KAAK,EAAE;AACpC,cAAc,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC;AAC7C,cAAc,CAAC,QAAQ,CAAC;AACxB,WAAW,CAAC;AACZ,SAAS;AACT,KAAK;AACL,GAAG,CAAC;AACJ,EAAE,OAAO,UAAU,CAAC;AACpB,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,eAAe,GAAG,CAAC,IAAI,EAAE,IAAI,cAAc;AACjD,EAAE,IAAI,IAAI,KAAK,KAAK;AACpB,IAAI,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;AACrB;AACA,EAAE,IAAI,IAAI,KAAK,MAAM;AACrB,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;AACtB;AACA,EAAE,IAAI,IAAI,KAAK,UAAU;AACzB,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;AACtB;AACA,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG;AAC9B,IAAI,OAAO,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AACvC;AACA,EAAE,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI;AAC/B,IAAI,OAAO,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC7B;AACA,EAAE,OAAO,SAAS,CAAC,IAAI,EAAE,IAAI,UAAU,CAAC;AACxC,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACO,SAAS,QAAQ,CAAC,OAAO,EAAE;AAClC,EAAE,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,OAAO,CAAC;AAC/B,EAAE,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;AAClD,EAAE,OAAO,IAAI,KAAK,MAAM;AACxB,IAAI,cAAc,CAAC,IAAI,CAAC;AACxB,KAAK,IAAI,KAAK,MAAM;AACpB,MAAM,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,kBAAkB;AAC1D,MAAM,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AAClB;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,MAAM,GAAG,KAAK,CAAC;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC;AAChC;AACO,MAAM,WAAW,GAAG,OAAO;AAClC,EAAE,KAAK,EAAE,EAAE;AACX;AACA,EAAE,KAAK,EAAE,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI,EAAE,IAAI;AACZ;AACA;AACA,CAAC,CAAC,CAAC;AACH;AACA;AACA,MAAM,WAAW,GAAG,CAAC,IAAI,EAAE,QAAQ,KAAK;AACxC,EAAE,MAAM,CAAC,OAAO,EAAE,OAAO,CAAC,GAAG,UAAU,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACxD,EAAE,OAAO,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AACxD,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA,MAAM,WAAW,GAAG,CAAC,IAAI,EAAE,QAAQ,KAAK;AACxC,EAAE,MAAM,IAAI,GAAG,UAAU,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,KAAK,KAAK,CAAC,CAAC;AAC5D,EAAE,MAAM,OAAO,GAAG,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAC7C;AACA;AACA,EAAE,MAAM,EAAE,GAAG,YAAY,CAAC,OAAO,CAAC,CAAC;AACnC,EAAE,MAAM,KAAK,GAAG,EAAE,CAAC;AACnB,EAAE,MAAM,MAAM,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;AACrC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;AACZ;AACA;AACA,EAAE,IAAI,MAAM,GAAG,CAAC,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AAC/B,EAAE,OAAO,CAAC,GAAG,MAAM,EAAE;AACrB,IAAI,MAAM,IAAI,GAAG,EAAE,CAAC,QAAQ,EAAE,CAAC;AAC/B;AACA;AACA,IAAI,IAAI,CAAC,IAAI;AACb,MAAM,MAAM,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC,CAAC;AACpC;AACA;AACA,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,EAAE;AAC7B;AACA;AACA,MAAM,IAAI,IAAI,CAAC,WAAW,KAAK,MAAM,EAAE;AACvC,QAAQ,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC3D,QAAQ,MAAM,GAAG,CAAC,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;AACnC,OAAO;AACP,KAAK;AACL,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAM,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE;AACxC,QAAQ,KAAK,CAAC,IAAI,CAAC;AACnB,UAAU,IAAI,EAAE,MAAM;AACtB,UAAU,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC;AAChC,UAAU,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC;AACzC;AACA,SAAS,CAAC,CAAC;AACX,QAAQ,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;AACrC,QAAQ,MAAM,GAAG,CAAC,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;AACnC,OAAO;AACP;AACA;AACA,MAAM;AACN,QAAQ,uBAAuB,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;AAClD,QAAQ,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,GAAG,CAAC;AACtD,OAAO;AACP,QAAQ,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;AAC9B,QAAQ,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC3D,QAAQ,MAAM,GAAG,CAAC,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;AACnC,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AAC1B,CAAC,CAAC;AACF;AACA;AACA;AACA,MAAM,UAAU,GAAG,CAAC,IAAI,EAAE,QAAQ,KAAK;AACvC,EAAE,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC;AACxB,IAAI,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC;AACvB,IAAI,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACpD,GAAG,CAAC;AACJ;AACA,EAAE,MAAM,QAAQ,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;AAC5D;AACA,EAAE,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;AAChD;AACA,EAAE,OAAO,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AACtC,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACO,MAAM,MAAM,GAAG,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,CAAC,KAAK;AAC1D,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;AAC1B;AACA;AACA,EAAE,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AACrC,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;AACrB;AACA;AACA;AACA,EAAE,IAAI,CAAC,KAAK,KAAK,KAAK,CAAC,QAAQ,KAAK,QAAQ,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,CAAC;AACpE,IAAI,IAAI,CAAC,KAAK,IAAI,KAAK,GAAG,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;AACvD,EAAE,MAAM,CAAC,OAAO,EAAE,OAAO,EAAE,IAAI,CAAC,GAAG,KAAK,CAAC;AACzC;AACA;AACA,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE;AACjC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AAC1B;AACA;AACA;AACA;AACA,EAAE,OAAO,IAAI,KAAK,KAAK,CAAC,IAAI,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;AACpD,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA,MAAM,YAAY,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,MAAM,KAAK;AAClD,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;AACnC,IAAI,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAC3B;AACA;AACA,IAAI,IAAI,IAAI,YAAY,IAAI;AAC5B,MAAM,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM;AACxB,QAAQ,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,GAAG,WAAW,EAAE,CAAC;AAC9C,QAAQ,IAAI;AACZ,OAAO,CAAC;AACR;AACA;AACA,SAAS,IAAI,OAAO,CAAC,IAAI,CAAC;AAC1B,MAAM,YAAY;AAClB,QAAQ,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,GAAG,WAAW,EAAE,CAAC;AAC9C,QAAQ,IAAI;AACZ,QAAQ,IAAI,CAAC,MAAM;AACnB,OAAO,CAAC;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;AACtB,GAAG;AACH,EAAE,IAAI,MAAM,GAAG,KAAK,CAAC,MAAM;AAC3B,IAAI,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;AACzB,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE;AAC7C,EAAE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACnB,EAAE,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;AAC3B,EAAE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;AACvB;;ACnMA,MAAM,CAAC,MAAM,EAAE,gBAAgB,CAAC,GAAG,MAAM,CAAC;AAC1C;AACA;AACA;AACA,MAAM,GAAG,GAAG,IAAI,IAAI;AACpB;AACA,EAAE,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC;AAClC;AACA;AACA,EAAE,MAAM,KAAK,GAAG,KAAK,IAAI,CAAC,QAAQ,EAAE,GAAG,MAAM,KAAK,MAAM;AACxD,IAAI,KAAK;AACT,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,CAAC;AAC5B,GAAG,CAAC;AACJ,EAAE,OAAO,gBAAgB;AACzB;AACA;AACA,IAAI,CAAC,QAAQ,EAAE,GAAG,MAAM,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,CAAC;AAC7D,IAAI;AACJ,MAAM,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA,QAAQ,KAAK,CAAC,GAAG,EAAE,EAAE,EAAE;AACvB,UAAU,MAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AACtE,UAAU,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;AAC/D,SAAS;AACT,OAAO;AACP,MAAM,IAAI,EAAE;AACZ;AACA;AACA;AACA,QAAQ,KAAK,EAAE,CAAC,QAAQ,EAAE,GAAG,MAAM,KAAK,MAAM;AAC9C,UAAU,WAAW,EAAE;AACvB,UAAU,CAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,CAAC;AAClC,SAAS,CAAC,OAAO,EAAE;AACnB,OAAO;AACP,KAAK;AACL,GAAG,CAAC;AACJ,CAAC,CAAC;AACF;AACA;AACA,MAAMA,OAAK,GAAG,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,MAAM,GAAG,CAAC,KAAK,EAAE,IAAI,KAAK;AAChC,EAAE,MAAM,IAAI,GAAG,OAAO,IAAI,KAAK,UAAU,GAAG,IAAI,EAAE,GAAG,IAAI,CAAC;AAC1D,EAAE,MAAM,IAAI,GAAGA,OAAK,CAAC,GAAG,CAAC,KAAK,CAAC,IAAIA,OAAK,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,EAAE,CAAC,CAAC;AACnE,EAAE,MAAM,IAAI,GAAG,IAAI,YAAY,IAAI,GAAG,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;AAChE,EAAE,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,EAAE;AAC1B,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;AACrB,IAAI,KAAK,CAAC,WAAW,GAAG,EAAE,CAAC;AAC3B;AACA;AACA;AACA;AACA,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC;AACtC,GAAG;AACH,EAAE,OAAO,KAAK,CAAC;AACf,CAAC,CAAC;AACF;AACK,MAAC,IAAI,GAAG,GAAG,CAAC,MAAM,EAAE;AACzB,MAAM,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC;;ACrEP,cAAQ,EAAE,CAAC,EAAE;AAC5B,EAAE,KAAK,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;AAC5D,IAAI,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7B,EAAE,OAAO,CAAC,CAAC;AACX;;ACIA;;;;;MAKMC,KAAG,GAAG,OAAsC,EAAE,OAAO,EAAE,IAAI,EAAE,EAAE;AAiFrE,MAAM,qBAAqB,GAAG,IAAI,GAAG,EAAmD,CAAC;AAEzF;;;;;;;;;;MAUM,SAAS,GAAG,CAAC,aAAuC,WAAW;IACnE,IAAI,QAAQ,GAAG,qBAAqB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IACrD,IAAI,QAAQ,EAAE;QACZ,OAAO,QAAQ,CAAC;KACjB;IAED,MAAM,QAAQ,GAAG,cAAc,UAAU;QACvC,KAAK;QAEL,WAAW,CAAC,KAAY;YACtB,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;SAClD;QAED,QAAQ,CAAI,KAAe;YACzB,OAAO,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SAC9B;KACF,CAAA;IAED,qBAAqB,CAAC,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;IAEhD,OAAO,QAAQ,CAAC;AAClB,EAAC;AAED,MAAM,cAAc,GAAG,IAAI,OAAO,EAAyB,CAAC;AAC5D,MAAM,cAAc,GAAG,IAAI,OAAO,EAAE,CAAC;AACrC,IAAI,gBAAgB,GAAG,IAAI,GAAG,EAAc,CAAC;AAE7C,MAAM,YAAY,GAAG,IAAI,GAAG,EAAgD,CAAC;AAE7E;;;;;;;;;MASM,MAAM,GAAG,CAAC,GAAW,EAAE,UAAiC,EAAE,OAAiC,EAAE;IAEjG,MAAM,KAAK,GAAG,YAAY,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,cAAc,UAAU;QACpE,iBAAiB;YACf,IAAI,KAAK,CAAC,SAAS;gBAAE,KAAK,CAAC,SAAS,EAAE,CAAC;YAEvC,IAAI,CAAC,aAAa,CAAC,IAAI,WAAW,CAAC,WAAW,CAAC,CAAC,CAAC;YAEjD,UAAU,CAAC,MAAM,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;SAChC;QAED,KAAK;YACH,UAAU,CAAC,IAAI,CAAC,CAAC;YAEjB,IAAI,KAAK,CAAC,KAAK,EAAE;gBACf,KAAK,CAAC,KAAK,EAAE,CAAC;aACf;YAED,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;YAExB,IAAI,CAAC,aAAa,CAAC,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;YAE7C,eAAe,CAAC,IAAI,CAAC,CAAC;SACvB;QAED,oBAAoB;YAClB,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,MAAM;gBACtC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;aAClB,CAAC,CAAC;YAEH,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAC5B,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAE5B,IAAI,KAAK,CAAC,YAAY,EAAE;gBACtB,KAAK,CAAC,YAAY,EAAE,CAAC;aACtB;YAED,IAAI,CAAC,aAAa,CAAC,IAAI,WAAW,CAAC,cAAc,CAAC,CAAC,CAAC;SACrD;QAED,MAAM;YACJ,IAAI,KAAK,CAAC,MAAM;gBACd,KAAK,CAAC,MAAM,EAAE,CAAC;YACjB,IAAI,IAAI,CAAC,MAAM;gBAAE,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;SAC9C;QAED,WAAW,CAAC,KAAY;YACtB,IAAI,CAAC,KAAK,CAAC,WAAW;gBACpB,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,UAAU,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;;gBAEjD,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;SAC5B;QAED,QAAQ,CAAI,KAAe;YACzB,OAAO,QAAQ,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SAC9B;KACF,CAAC;IAEF,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC;QAAE,cAAc,CAAC,MAAM,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,CAAA;IAErE,IAAI,UAAU,CAAC,GAAG,EAAE;QAClB,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAC9C,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,GAAG,GAAG,IAAI,CAAC,OAAO,OAAO,GAAG,GAAG,GAAG,GAAG,CAAC;QACnE,KAAK,CAAC,WAAW,GAAG,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAC7C,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;KAClC;IAED,YAAY,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IAEpC,OAAO,KAAK,CAAC;AACf,EAAC;AAED,MAAM,YAAY,GAAG;IACnB,MAAM,QAAQ,GAAG,gBAAgB,CAAC;IAClC,gBAAgB,GAAG,IAAI,GAAG,EAAE,CAAC;IAC7B,QAAQ,CAAC,OAAO,CAAC,OAAO;QACtB,OAAO,CAAC,MAAM,IAAI,CAAC;KACpB,CAAC,CAAC;AACL,CAAC,CAAA;AAED,MAAM,eAAe,GAAG,CAAC,OAAmB;IAC1C,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;QAClC,gBAAgB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAE9B,IAAI,gBAAgB,CAAC,IAAI,KAAK,CAAC,EAAE;YAC/B,IAAI,CAAC,YAAY,CAAC,CAAC;SACpB;KACF;AACH,CAAC,CAAA;AAED,MAAM,IAAI,GAAG,CAAC,QAAkB;IAC9B,CAAC,MAAM,CAAC,cAAc;UAClB,MAAM,CAAC,cAAc,CAAC,QAAwB,CAAC;UAC/C,IAAI,OAAO,CAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,QAAwB,CAAC,CAAC;AACjE,CAAC,CAAA;AAED;;;;;;;;;AASA,MAAM,WAAW,GAAG,IAAI,OAAO,EAAE,CAAC;AAClC,MAAM,UAAU,GAAG,CAAC,OAAmB;;IAErC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;QAC7B,IAAI,aAAa,GAAW,EAAE,CAAC;QAC/B,IAAI,KAAK,GAAyB,EAAE,CAAC;QACrC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,EAAE;YACvC,MAAM,QAAQ,GAAG,CAAC,EAAE,YAAY,OAAO,IAAI,EAAE,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;YAE1E,IAAI,QAAQ,EAAE;gBACZ,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAA;aACrB;iBAAM;gBACL,aAAa,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aACxB;SACF,CAAC,CAAC;QACH,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,EAAE,OAAO,EAAE,aAAa,EAAE,GAAG,KAAK,EAAE,CAAC,CAAC;QACpE,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;KAC1B;AACH,CAAC,CAAA;AAED;;;;MAIM,QAAQ,GAAG,CAAI,OAAmB,EAAE,KAAe;IACvD,MAAM,OAAO,GAAG,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;IAClD,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC;;;QAGxB,IAAI,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC;YAAE,eAAe,CAAC,OAAO,CAAC,CAAC;KAC3D,CAAC,CAAC;IACH,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACtB,cAAc,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IAErC,OAAO,KAAK,CAAC;AACf;;;;;;;;;"}